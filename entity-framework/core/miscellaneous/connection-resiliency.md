---
title: Устойчивость подключений — EF Core
author: rowanmiller
ms.date: 11/15/2016
ms.assetid: e079d4af-c455-4a14-8e15-a8471516d748
uid: core/miscellaneous/connection-resiliency
ms.openlocfilehash: 6d8cf117dfd94524a53e10bb4a23c2a44c4c8e7b
ms.sourcegitcommit: 33b2e84dae96040f60a613186a24ff3c7b00b6db
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/21/2019
ms.locfileid: "56459176"
---
# <a name="connection-resiliency"></a>Устойчивость подключений

Устойчивость подключения автоматически осуществляет новую попытку команды поврежденной базы данных. Эта функция может использоваться с любой базой данных, указав «стратегия выполнения», который инкапсулирует логику, необходимую для обнаружения сбоев и повторите команды. Поставщики EF Core может предоставлять адаптированные для их условия сбоя конкретной базы данных и политики повтора оптимальной стратегии выполнения.

Например поставщик SQL Server включает в себя стратегии выполнения, специально предназначенную для SQL Server (включая SQL Azure). Он учитывает типы исключений, которые могут быть повторены и содержит допустимые значения по умолчанию максимальное число повторных попыток, задержку между повторными попытками и т. д.

Стратегия выполнения указывается при настройке параметров для текущего контекста. Это обычно находится в `OnConfiguring` метода производного контекста:

[!code-csharp[Main](../../../samples/core/Miscellaneous/ConnectionResiliency/Program.cs#OnConfiguring)]

или в `Startup.cs` для приложения ASP.NET Core:

``` csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddDbContext<PicnicContext>(
        options => options.UseSqlServer(
            "<connection string>",
            providerOptions => providerOptions.EnableRetryOnFailure()));
}
```

## <a name="custom-execution-strategy"></a>Стратегия выполнения пользовательских

Нет механизма регистрации стратегию выполнения пользовательских своим собственным в том случае, если вы хотите изменить любые параметры по умолчанию.

``` csharp
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
    optionsBuilder
        .UseMyProvider(
            "<connection string>",
            options => options.ExecutionStrategy(...));
}
```

## <a name="execution-strategies-and-transactions"></a>Стратегии выполнения и транзакции

Стратегия выполнения, которая автоматически осуществляет новую попытку в случае сбоев необходимо иметь возможность воспроизвести каждой операции в блоке повторных попыток, которое не удается. После включения повторных попыток, каждой операции, выполняемые с помощью EF Core становится отдельной повторяемые операции. То есть каждый запрос и каждый вызов `SaveChanges()` будет повторена как единое целое, при возникновении временного сбоя.

Тем не менее если код запускает транзакцию с помощью `BeginTransaction()` вы определяете собственную группу операций, которые должны рассматриваться как единое целое, и все содержимое транзакции необходимо воспроизводить должен произойти сбой. Если попытаться сделать это, при использовании стратегии выполнения, вы получите исключение, как показано ниже:

> InvalidOperationException: The configured execution strategy 'SqlServerRetryingExecutionStrategy' does not support user initiated transactions" (System.InvalidOperationException: настроенная стратегия выполнения SqlServerRetryingExecutionStrategy не поддерживает запуск транзакций пользователем). Используйте стратегию выполнения, возвращенную 'DbContext.Database.CreateExecutionStrategy()', чтобы выполнить все операции в транзакции как повторяемую единицу.

Решение заключается в том, чтобы вызвать стратегию выполнения с помощью делегата, который представляет все, нужно выполнить вручную. В случае временного сбоя стратегия выполнения будет снова вызывать делегат.

[!code-csharp[Main](../../../samples/core/Miscellaneous/ConnectionResiliency/Program.cs#ManualTransaction)]

Этот подход можно также использовать с внешней транзакции.

[!code-csharp[Main](../../../samples/core/Miscellaneous/ConnectionResiliency/Program.cs#AmbientTransaction)]

## <a name="transaction-commit-failure-and-the-idempotency-issue"></a>Ошибка фиксации транзакции и проблема идемпотентности

В общем случае при сбое подключения текущая транзакция откатывается. Тем не менее, если соединение разорвано во время транзакции благосостояние зафиксирована полученный в результате состояние транзакции неизвестно. См. в разделе, это [блога](https://blogs.msdn.com/b/adonet/archive/2013/03/11/sql-database-connectivity-and-the-idempotency-issue.aspx) для получения дополнительных сведений.

По умолчанию, стратегия выполнения будет повторять эту операцию, так как в том случае, если откат транзакции, но если это не так это приведет к исключение, если новое состояние базы данных несовместим или может привести к **повреждения данных** Если Операция не полагаться на определенном состоянии, например при вставке новой строки с помощью автоматически сформированных значений ключа.

Существует несколько способов решения этой проблемы.

### <a name="option-1---do-almost-nothing"></a>Вариант 1. nothing (почти)

Вероятность сбоя подключения во время фиксации транзакции недостаточно, поэтому оно может быть приемлемым для вашего приложения, просто ошибкой, если данное состояние возникает, фактически.

Тем не менее необходимо избегать использования сформированные хранилищем ключи, чтобы гарантировать, что исключение вместо добавления повторяющуюся строку. Рекомендуется использовать значение идентификатора GUID, сформированное клиентом или генератор значение на стороне клиента.

### <a name="option-2---rebuild-application-state"></a>Вариант 2 - состояния приложения перестроения

1. Отменить текущий `DbContext`.
2. Создайте новый `DbContext` и восстановить состояние приложения из базы данных.
3. Информировать пользователей о том, что последняя операция не выполнена успешно.

### <a name="option-3---add-state-verification"></a>Вариант 3: Добавление проверки состояния

Для большинства операций, которые изменяют состояние базы данных можно добавить код, который проверяет, успешно ли оно выполнено. EF предоставляет метод расширения, чтобы облегчить эту задачу - `IExecutionStrategy.ExecuteInTransaction`.

Этот метод начинает и фиксирует транзакцию, а также принимает функцию в `verifySucceeded` параметр, который вызывается, когда возникает временная ошибка во время фиксации транзакции.

[!code-csharp[Main](../../../samples/core/Miscellaneous/ConnectionResiliency/Program.cs#Verification)]

> [!NOTE]
> Здесь `SaveChanges` вызывается с `acceptAllChangesOnSuccess` присвоено `false` во избежание изменения состояния `Blog` сущность `Unchanged` Если `SaveChanges` завершается успешно. Это позволяет повторите ту же операцию, если фиксация завершается сбоем и выполняется откат транзакции.

### <a name="option-4---manually-track-the-transaction"></a>Вариант 4: вручную отслеживания транзакции

Если требуется использовать сформированные хранилищем ключи или вам требуется универсальный способ обработки сбоев, не зависящая от операции, выполняемой каждой транзакции можно было назначать идентификатор, который проверяется при фиксация завершается сбоем.

1. Добавление таблицы в базу данных, используемый для отслеживания состояния транзакций.
2. Вставьте строку в таблице в начале каждой транзакции.
3. В случае сбоя подключения во время фиксации, проверьте наличие соответствующей строки в базе данных.
4. Если фиксация выполнена успешно, удалите соответствующей строки во избежание увеличение размера таблицы.

[!code-csharp[Main](../../../samples/core/Miscellaneous/ConnectionResiliency/Program.cs#Tracking)]

> [!NOTE]
> Убедитесь, что контекст, используемый для проверки стратегии выполнения определяются как соединение может привести к отказу во время проверки, если не удалось выполнить во время фиксации транзакции.
