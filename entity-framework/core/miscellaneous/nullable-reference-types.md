---
title: Работа с ссылочными типами, допускающими значение NULL — EF Core
author: roji
ms.date: 9/9/2019
ms.assetid: bde4e0ee-fba3-4813-a849-27049323d301
uid: core/miscellaneous/nullable-reference-types
ms.openlocfilehash: 1aa49f1ed518dfe4c13976cef8e868f58d12d5a3
ms.sourcegitcommit: ec196918691f50cd0b21693515b0549f06d9f39c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/23/2019
ms.locfileid: "71204405"
---
# <a name="working-with-nullable-reference-types"></a>Работа с ссылочными типами, допускающими значение null

C#в 8 появилась новая функция, называемая [ссылочными типами, допускающими значение NULL](/dotnet/csharp/tutorials/nullable-reference-types), которая позволяет создавать заметки для ссылочных типов, указывая, является ли он допустимым для того, чтобы они содержали значение null. Если вы не знакомы с этой функцией, рекомендуется ознакомиться с ней, прочитав C# документацию.

На этой странице EF Core вводится поддержка ссылочных типов, допускающих значения NULL, и приводятся рекомендации по работе с ними.

## <a name="required-and-optional-properties"></a>Обязательные и необязательные свойства

Основная документация по обязательным и дополнительным свойствам и их взаимодействию с ссылочными типами, допускающими значение null, — это [обязательная и необязательная страница свойств](xref:core/modeling/required-optional) . Для начала рекомендуется сначала прочитать эту страницу.

> [!NOTE]
> Соблюдайте осторожность при включении ссылочных типов, допускающих значение null, в существующем проекте: свойства ссылочного типа, которые ранее были настроены как необязательные, теперь будут настроены как обязательные, если только они не имеют явно заметку null. При управлении схемой реляционной базы данных это может привести к созданию миграции, которые изменяют допустимость значений NULL в столбце базы данных.

## <a name="dbcontext-and-dbset"></a>DbContext и DbSet

Если ссылочные типы, допускающие значение C# null, включены, компилятор выдает предупреждения для любого неинициализированного свойства, не допускающего значения NULL, так как это может содержать значение null. В результате, как правило, при определении значения, не допускающего `DbSet` значение null, в контексте будет выдаваться предупреждение. Однако EF Core всегда инициализирует все `DbSet` свойства в типах, производных от DbContext, поэтому они гарантированно никогда не будут иметь значение null, даже если компилятор не знает об этом. Поэтому рекомендуется, чтобы `DbSet` свойства не допускали значения NULL, позволяя получать доступ к ним без проверки значений NULL. Кроме того, для предотвращения предупреждений компилятора следует явно задать для них значение NULL с помощью оператора NULL-терпим отношению (!):

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/NullableReferenceTypesContext.cs?name=Context&highlight=3-4)]

## <a name="non-nullable-properties-and-initialization"></a>Свойства и инициализация, не допускающая значения NULL

Предупреждения компилятора для неинициализированных ссылочных типов также являются проблемой для обычных свойств типов сущностей. В нашем примере мы исключаем эти предупреждения с помощью [привязки конструктора](xref:core/modeling/constructors), функции, которая идеально подходит для свойств, не допускающих значения NULL, гарантируя, что они всегда инициализированы. Однако в некоторых сценариях привязка конструктора не является вариантом: свойства навигации, например, не могут быть инициализированы таким образом.

Обязательные свойства навигации представляют дополнительную сложность: Несмотря на то, что зависимый объект всегда будет существовать для данного участника, он может быть или не загружен определенным запросом в зависимости от потребностей в этой точке программы (см.[различные шаблоны для Загрузка данных](xref:core/querying/related-data)). В то же время нежелательно делать эти свойства допускающими значение null, так как это приведет к тому, что все права доступа к ним будут проверять наличие значения NULL, даже если они требуются.

Одним из способов решения этих сценариев является наличие свойства, не допускающего значения NULL, с [резервным полем](xref:core/modeling/backing-field), допускающим значение null.

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/Order.cs?range=12-17)]

Так как свойство навигации не допускает значения NULL, необходимо настроить требуемую навигацию. и при условии, что Навигация правильно загружена, зависимый объект будет доступен через свойство. Однако если доступ к свойству осуществляется без предварительной загрузки связанной сущности, создается исключение InvalidOperationException, так как контракт API используется неправильно.

В качестве более сжатого альтернативного варианта можно просто инициализировать свойство значением NULL с помощью оператора NULL-терпим отношению (!):

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/Order.cs?range=19)]

Фактическое значение NULL не будет наблюдаться, за исключением случая программной ошибки, например при доступе к свойству навигации без правильной загрузки связанной сущности заранее.

> [!NOTE]
> Переходы по коллекциям, которые содержат ссылки на несколько связанных сущностей, всегда должны быть не допускать значения NULL. Пустая коллекция означает, что связанные сущности не существуют, но сам список никогда не должен иметь значение null.

## <a name="navigating-and-including-nullable-relationships"></a>Навигация и включение отношений, допускающих значение null

При работе с необязательными связями можно столкнуться с предупреждениями компилятора, в которых фактическое исключение пустой ссылки было бы невозможно. При преобразовании и выполнении запросов LINQ EF Core гарантирует, что если необязательная связанная сущность не существует, любую навигацию для нее просто пропускается, а не создается. Однако компилятор не знает об этой EF Core гарантии и выдает предупреждения, как если бы запрос LINQ выполнялся в памяти, с LINQ to Objects. Поэтому необходимо использовать оператор NULL-терпим отношению (!) для информирования компилятора о том, что фактическое значение NULL невозможно:

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/Program.cs?range=46)]

Аналогичная проблема возникает при включении нескольких уровней связей в необязательные переходы:

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/Program.cs?range=36-39&highlight=2)]

Если вы считаете, что сделали это очень много, и рассматриваемые типы сущностей являются преимущественно (или исключительно), используемыми в запросах EF Core, рассмотрите возможность создания свойств навигации, не допускающих значения NULL, и настройки их как необязательных через API-интерфейс или заметки к данным. Это приведет к удалению всех предупреждений компилятора, сохраняя связь необязательной. Однако если сущности обходятся за пределами EF Core, можно заметить значения NULL, хотя свойства записываются как не допускающие значения NULL.

## <a name="scaffolding"></a>Формирование шаблонов

[Функция C# ссылочного типа 8 Nullable](/dotnet/csharp/tutorials/nullable-reference-types) в настоящее время не поддерживается в обратном проектировании: EF Core всегда создает C# код, который предполагает, что функция отключена. Например, столбцы с текстом, допускающими значение null, будут формироваться в `string` виде свойства `string?`с типом, а не с помощью API-интерфейса Fluent или заметок к данным, используемых для настройки того, является ли свойство обязательным. Можно изменить сформированный код и заменить его заметками C# , имеющими значения NULL. Поддержка формирования шаблонов для ссылочных типов, допускающих значения NULL, ведется по выпуску [#15520](https://github.com/aspnet/EntityFrameworkCore/issues/15520).
