---
title: Работа с ссылочными типами, допускающими значение NULL — EF Core
author: roji
ms.date: 09/09/2019
ms.assetid: bde4e0ee-fba3-4813-a849-27049323d301
uid: core/miscellaneous/nullable-reference-types
ms.openlocfilehash: c16a475c363320cd18804a4efe78ccae1ae22f0d
ms.sourcegitcommit: f2a38c086291699422d8b28a72d9611d1b24ad0d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/16/2020
ms.locfileid: "76124357"
---
# <a name="working-with-nullable-reference-types"></a>Работа с ссылочными типами, допускающими значение null

C#в 8 появилась новая функция, называемая [ссылочными типами, допускающими значение NULL](/dotnet/csharp/tutorials/nullable-reference-types), которая позволяет создавать заметки для ссылочных типов, указывая, является ли он допустимым для того, чтобы они содержали значение null. Если вы не знакомы с этой функцией, рекомендуется ознакомиться с ней, прочитав C# документацию.

На этой странице EF Core вводится поддержка ссылочных типов, допускающих значения NULL, и приводятся рекомендации по работе с ними.

## <a name="required-and-optional-properties"></a>Обязательные и необязательные свойства

Основная документация по обязательным и дополнительным свойствам и их взаимодействию с ссылочными типами, допускающими значение null, — это [обязательная и необязательная страница свойств](xref:core/modeling/entity-properties#required-and-optional-properties) . Для начала рекомендуется сначала прочитать эту страницу.

> [!NOTE]
> Соблюдайте осторожность при включении ссылочных типов, допускающих значение null, в существующем проекте: свойства ссылочного типа, которые ранее были настроены как необязательные, теперь будут настроены как обязательные, если только они не имеют явно заметку null. При управлении схемой реляционной базы данных это может привести к созданию миграции, которые изменяют допустимость значений NULL в столбце базы данных.

## <a name="dbcontext-and-dbset"></a>DbContext и DbSet

Если ссылочные типы, допускающие значение C# null, включены, компилятор выдает предупреждения для любого неинициализированного свойства, не допускающего значения NULL, так как это может содержать значение null. В результате, как правило, при определении `DbSet`, не допускающего значения NULL, в контексте будет выдаваться предупреждение. Однако EF Core всегда инициализирует все свойства `DbSet` в типах, производных от DbContext, поэтому они гарантированно никогда не будут иметь значение null, даже если компилятор не знает об этом. Поэтому рекомендуется, чтобы свойства `DbSet`, не допускающие значения NULL, позволяли обращаться к ним без проверки значений NULL. Кроме того, можно отменять предупреждения компилятора, явно присвоив им значение NULL с помощью оператора NULL-терпим отношению (!):

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/NullableReferenceTypesContext.cs?name=Context&highlight=3-4)]

## <a name="non-nullable-properties-and-initialization"></a>Свойства и инициализация, не допускающая значения NULL

Предупреждения компилятора для неинициализированных ссылочных типов также являются проблемой для обычных свойств типов сущностей. В нашем примере мы исключаем эти предупреждения с помощью [привязки конструктора](xref:core/modeling/constructors), функции, которая идеально подходит для свойств, не допускающих значения NULL, гарантируя, что они всегда инициализированы. Однако в некоторых сценариях привязка конструктора не является вариантом: свойства навигации, например, не могут быть инициализированы таким образом.

Обязательные свойства навигации представляют дополнительную сложность: Несмотря на то, что зависимый объект всегда будет существовать для данного участника, он может быть или не загружен определенным запросом в зависимости от потребностей в этой точке программы (см.[различные шаблоны для загрузки данных](xref:core/querying/related-data)). В то же время нежелательно делать эти свойства допускающими значение null, так как это приведет к тому, что все права доступа к ним будут проверять наличие значения NULL, даже если они требуются.

Одним из способов решения этих сценариев является наличие свойства, не допускающего значения NULL, с [резервным полем](xref:core/modeling/backing-field), допускающим значение null.

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/Order.cs?range=10-17)]

Так как свойство навигации не допускает значения NULL, необходимо настроить требуемую навигацию. и при условии, что Навигация правильно загружена, зависимый объект будет доступен через свойство. Однако если доступ к свойству осуществляется без предварительной загрузки связанной сущности, создается исключение InvalidOperationException, так как контракт API используется неправильно. Обратите внимание, что EF должен быть настроен так, чтобы всегда обращаться к резервному полю, а не к свойству, так как оно зависит от возможности чтения значения даже при неопределенном значении. сведения о том, как это сделать, см. в документации по [резервным полям](xref:core/modeling/backing-field) . чтобы убедиться в правильности конфигурации, рассмотрите документацию по параметрам `PropertyAccessMode.Field`.

В качестве более сжатого альтернативного варианта можно просто инициализировать свойство значением NULL с помощью оператора NULL-терпим отношению (!):

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/Order.cs?range=19)]

Фактическое значение NULL не будет наблюдаться, за исключением случая программной ошибки, например при доступе к свойству навигации без правильной загрузки связанной сущности заранее.

> [!NOTE]
> Переходы по коллекциям, которые содержат ссылки на несколько связанных сущностей, всегда должны быть не допускать значения NULL. Пустая коллекция означает, что связанные сущности не существуют, но сам список никогда не должен иметь значение null.

## <a name="navigating-and-including-nullable-relationships"></a>Навигация и включение отношений, допускающих значение null

При работе с необязательными связями можно столкнуться с предупреждениями компилятора, в которых фактическое исключение пустой ссылки было бы невозможно. При преобразовании и выполнении запросов LINQ EF Core гарантирует, что если необязательная связанная сущность не существует, любую навигацию для нее просто пропускается, а не создается. Однако компилятор не знает об этой EF Core гарантии и выдает предупреждения, как если бы запрос LINQ выполнялся в памяти, с LINQ to Objects. Поэтому необходимо использовать оператор NULL-терпим отношению (!) для информирования компилятора о том, что фактическое значение NULL невозможно:

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/Program.cs?range=46)]

Аналогичная проблема возникает при включении нескольких уровней связей в необязательные переходы:

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/Program.cs?range=36-39&highlight=2)]

Если вы считаете, что сделали это очень много, и рассматриваемые типы сущностей являются преимущественно (или исключительно), используемыми в запросах EF Core, рассмотрите возможность создания свойств навигации, не допускающих значения NULL, и настройки их как необязательных через API-интерфейс или заметки к данным. Это приведет к удалению всех предупреждений компилятора, сохраняя связь необязательной. Однако если сущности обходятся за пределами EF Core, можно заметить значения NULL, хотя свойства записываются как не допускающие значения NULL.

## <a name="limitations"></a>Ограничения

* В настоящее время реконструирование не поддерживает [ C# 8 ссылочных типов, допускающих значения NULL (НРТС)](/dotnet/csharp/tutorials/nullable-reference-types): EF Core всегда создает C# код, который предполагает, что функция отключена. Например, текстовые столбцы, допускающие значение null, будут формироваться в виде свойства с типом `string`, а не `string?`с помощью интерфейса API Fluent или заметок к данным, используемых для настройки того, является ли свойство обязательным. Можно изменить сформированный код и заменить его заметками C# , имеющими значения NULL. Поддержка формирования шаблонов для ссылочных типов, допускающих значения NULL, ведется по выпуску [#15520](https://github.com/aspnet/EntityFrameworkCore/issues/15520).
* У поверхности общедоступного API EF Core еще нет аннотации для допустимости значений NULL (общедоступный API — "null-очевидным"), что иногда может оказаться неудобным для использования при включенной функции ПРЕВЕНТИВНОЙ. Это особенно относится к асинхронным операторам LINQ, предоставляемым EF Core, таким как [фирстордефаултасинк](/dotnet/api/microsoft.entityframeworkcore.entityframeworkqueryableextensions.firstordefaultasync#Microsoft_EntityFrameworkCore_EntityFrameworkQueryableExtensions_FirstOrDefaultAsync__1_System_Linq_IQueryable___0__System_Linq_Expressions_Expression_System_Func___0_System_Boolean___System_Threading_CancellationToken_). Мы планируем устранить эту эту необходимость в выпуске 5,0.
