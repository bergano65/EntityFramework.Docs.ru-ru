---
title: Резервные поля — EF Core
author: rowanmiller
ms.date: 10/27/2016
ms.assetid: a628795e-64df-4f24-a5e8-76bc261e7ed8
uid: core/modeling/backing-field
ms.openlocfilehash: 20cf9dc9b0d556f29680bce588bcbdc4ea48fa74
ms.sourcegitcommit: f2a38c086291699422d8b28a72d9611d1b24ad0d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/16/2020
ms.locfileid: "76124383"
---
# <a name="backing-fields"></a>Резервные поля

Резервные поля позволяют EF читать и (или) записывать в поле, а не в свойство. Это может быть полезно, если Инкапсуляция в классе используется для ограничения использования и/или улучшения семантики доступа к данным с помощью кода приложения, но значение должно быть считано из базы данных и (или) записано в нее без использования этих ограничений и улучшений.

## <a name="basic-configuration"></a>Базовая конфигурация

В соответствии с соглашением следующие поля будут обнаружены как резервные поля для заданного свойства (в порядке приоритета). 

* `_<camel-cased property name>`
* `_<property name>`
* `m_<camel-cased property name>`
* `m_<property name>`

В следующем примере свойство `Url` настроено так, чтобы `_url` в качестве резервного поля:

[!code-csharp[Main](../../../samples/core/Modeling/Conventions/BackingField.cs#Sample)]

Обратите внимание, что резервные поля обнаруживаются только для свойств, которые включены в модель. Дополнительные сведения о том, какие свойства включены в модель, см. в разделе [включение & за исключением свойств](included-properties.md).

Можно также явно настроить резервное копирование полей, например, если имя поля не соответствует приведенным выше соглашениям:

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/BackingField.cs?name=BackingField&highlight=5)]

## <a name="field-and-property-access"></a>Доступ к полям и свойствам

По умолчанию EF всегда будет считывать и записывать данные в резервное поле (предполагая, что одно из них настроено правильно) и никогда не будет использовать свойство. Однако EF также поддерживает другие шаблоны доступа. Например, следующий пример указывает EF на запись в резервное поле только при материализации, а также на использование свойства во всех остальных случаях:

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/BackingFieldAccessMode.cs?name=BackingFieldAccessMode&highlight=6)]

Полный набор поддерживаемых параметров см. в [перечислении пропертякцессмоде](https://docs.microsoft.com/dotnet/api/microsoft.entityframeworkcore.propertyaccessmode) .

> [!NOTE]
> В EF Core 3,0 режим доступа к свойству по умолчанию изменился с `PreferFieldDuringConstruction` на `PreferField`.

## <a name="field-only-properties"></a>Свойства только для полей

Можно также создать концептуальное свойство в модели, которое не имеет соответствующего свойства CLR в классе сущности, а использует поле для хранения данных в сущности. Это отличается от [теневых свойств](shadow-properties.md), где данные хранятся в средстве записи изменений, а не в типе CLR сущности. Свойства, доступные только для полей, обычно используются, когда класс сущностей использует методы вместо свойств для получения и задания значений или в случаях, когда поля не должны быть представлены вообще в модели предметной области (например, первичные ключи).

Можно настроить свойство только для поля, указав имя в `Property(...)` API:

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/BackingFieldNoProperty.cs#Sample)]

EF будет пытаться найти свойство CLR с заданным именем или поле, если свойство не найдено. Если не найдено ни свойство, ни поле, будет настроено свойство теневого копирования.

Может потребоваться ссылка на свойство, доступное только для полей, из запросов LINQ, но такие поля обычно являются частными. Для ссылки на поле можно использовать метод `EF.Property(...)` в запросе LINQ.

``` csharp
var blogs = db.blogs.OrderBy(b => EF.Property<string>(b, "_validatedUrl"));
```
