---
title: Резервные поля — EF Core
author: rowanmiller
ms.date: 10/27/2016
ms.assetid: a628795e-64df-4f24-a5e8-76bc261e7ed8
uid: core/modeling/backing-field
ms.openlocfilehash: 288440a4494117fe59d27187e24424c4d2fd44ab
ms.sourcegitcommit: 2355447d89496a8ca6bcbfc0a68a14a0bf7f0327
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/23/2019
ms.locfileid: "72811876"
---
# <a name="backing-fields"></a>Резервные поля

> [!NOTE]  
> Эта функция впервые реализована в EF Core 1,1.

Резервные поля позволяют EF читать и (или) записывать в поле, а не в свойство. Это может быть полезно, если Инкапсуляция в классе используется для ограничения использования и (или) расширения семантики доступа к данным с помощью кода приложения, но значение должно считываться из базы данных и (или) записано в нее без использования этих ограничений/ усовершенствования.

## <a name="conventions"></a>Соглашения

В соответствии с соглашением следующие поля будут обнаружены как резервные поля для заданного свойства (в порядке приоритета). Поля обнаруживаются только для свойств, которые включены в модель. Дополнительные сведения о том, какие свойства включены в модель, см. в разделе [включение & за исключением свойств](included-properties.md).

* `_<camel-cased property name>`
* `_<property name>`
* `m_<camel-cased property name>`
* `m_<property name>`

[!code-csharp[Main](../../../samples/core/Modeling/Conventions/BackingField.cs#Sample)]

Если резервное поле настроено, EF будет записывать непосредственно в это поле при материализации экземпляров сущностей из базы данных (вместо использования метода задания свойств). Если EF необходимо прочитать или записать значение в другое время, по возможности будет использоваться свойство. Например, если EF необходимо обновить значение свойства, он будет использовать метод задания свойства, если он определен. Если свойство доступно только для чтения, оно будет записывать в поле.

## <a name="data-annotations"></a>Заметки к данным

Резервные поля не могут быть настроены с помощью заметок к данным.

## <a name="fluent-api"></a>Текучий API

С помощью API Fluent можно настроить резервное поле для свойства.

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/BackingField.cs#Sample)]

### <a name="controlling-when-the-field-is-used"></a>Управление при использовании поля

Можно настроить, когда EF использует поле или свойство. Поддерживаемые параметры см. в описании [перечисления пропертякцессмоде](https://docs.microsoft.com/dotnet/api/microsoft.entityframeworkcore.propertyaccessmode) .

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/BackingFieldAccessMode.cs#Sample)]

### <a name="fields-without-a-property"></a>Поля без свойства

Можно также создать концептуальное свойство в модели, которое не имеет соответствующего свойства CLR в классе сущности, а использует поле для хранения данных в сущности. Это отличается от [теневых свойств](shadow-properties.md), где данные хранятся в средстве записи изменений. Обычно это используется, если класс сущностей использует методы для получения или задания значений.

EF можно указать имя поля в `Property(...)` API. Если свойство с заданным именем отсутствует, то EF будет искать поле.

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/BackingFieldNoProperty.cs#Sample)]

Если в классе сущностей нет свойства, можно использовать метод `EF.Property(...)` в запросе LINQ для ссылки на свойство, которое концептуально является частью модели.

``` csharp
var blogs = db.blogs.OrderBy(b => EF.Property<string>(b, "_validatedUrl"));
```
