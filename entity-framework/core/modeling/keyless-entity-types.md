---
title: Типы сущностей без ключей — EF Core
description: Настройка типов сущностей без ключей с помощью Entity Framework Core
author: AndriySvyryd
ms.author: ansvyryd
ms.date: 9/13/2019
uid: core/modeling/keyless-entity-types
ms.openlocfilehash: 520c9ed93240c05deee36fa527a3757490fd7082
ms.sourcegitcommit: cc0ff36e46e9ed3527638f7208000e8521faef2e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78414647"
---
# <a name="keyless-entity-types"></a>Типы сущностей без ключей

> [!NOTE]
> Эта функция была добавлена в EF Core 2,1 под именем типов запросов. В EF Core 3,0 концепция была переименована в типы сущностей без ключей.

В дополнение к обычным типам сущностей модель EF Core может содержать незашифрованные _типы сущностей_, которые можно использовать для выполнения запросов к базе данных, не содержащей значений ключей.

## <a name="keyless-entity-types-characteristics"></a>Характеристики типов сущностей без ключей

Типы сущностей без ключей поддерживают многие из тех же возможностей сопоставления, что и обычные типы сущностей, такие как сопоставление наследования и свойства навигации. В реляционных хранилищах их можно настроить объекты целевой базы данных и столбцы с помощью текучего API методы или заметки к данным.

Однако они отличаются от обычных типов сущностей тем, что они:

- Ключ не может быть определен.
- Никогда не отправляются для изменений в _DbContext_ , поэтому они никогда не вставляются, не обновляются или не удаляются в базе данных.
- Никогда не обнаруживаются по соглашению.
- Поддерживаются только подмножество возможностей сопоставления навигации, в частности:
  - Они никогда не может выступать в качестве основной конец связи.
  - Они не могут иметь переходы к собственным сущностям
  - Они могут содержать только свойства навигации по ссылке, указывающие на обычные сущности.
  - Сущности не могут содержать свойства навигации для неключейых типов сущностей.
- Необходимо настроить с помощью вызова метода `.HasNoKey()`.
- Может быть сопоставлен с _определяющим запросом_. Определяющий запрос — это запрос, объявленный в модели, который выступает в качестве источника данных для типа сущности без ключей.

## <a name="usage-scenarios"></a>Сценарии использования

Ниже приведены некоторые основные сценарии использования для типов сущностей без ключей:

- Служит типом возвращаемого значения для [необработанных запросов SQL](xref:core/querying/raw-sql).
- Сопоставление с представлениями базы данных, которые не содержат первичный ключ.
- Сопоставление таблиц, у которых не определен первичный ключ.
- Сопоставление с запросами, определенными в модели.

## <a name="mapping-to-database-objects"></a>Сопоставление объектов базы данных

Сопоставление непеременного типа сущности с объектом базы данных достигается с помощью интерфейса API `ToTable` или `ToView` Fluent. С точки зрения EF Core, объект базы данных, указанный в этом методе, является _представлением_, то есть он обрабатывается как источник запроса только для чтения и не может быть целевым объектом операций обновления, вставки или удаления. Однако это не означает, что объект базы данных действительно должен быть представлением базы данных. В качестве альтернативы можно использовать таблицу базы данных, которая будет рассматриваться как доступная только для чтения. И наоборот, для обычных типов сущностей EF Core предполагается, что объект базы данных, указанный в методе `ToTable`, может рассматриваться как _Таблица_, что означает, что он может использоваться в качестве источника запроса, но также предназначен для операций обновления, удаления и вставки. На самом деле можно указать имя представления базы данных в `ToTable` и все должно работать, пока представление настроено для обновления в базе данных.

> [!NOTE]
> `ToView` предполагает, что объект уже существует в базе данных и не создается при миграции.

## <a name="example"></a>Пример

В следующем примере показано, как использовать типы сущностей без ключей для запроса представления базы данных.

> [!TIP]
> Для этой статьи вы можете скачать [пример](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/KeylessEntityTypes) из репозитория GitHub.

Во-первых определим простую модель блога и Post.

[!code-csharp[Main](../../../samples/core/KeylessEntityTypes/Program.cs#Entities)]

Далее мы определим представление простой базы данных, которые позволят нам запросить число сообщений, связанных с каждого блога:

[!code-csharp[Main](../../../samples/core/KeylessEntityTypes/Program.cs#View)]

Далее мы определим класс для хранения результата из представления базы данных:

[!code-csharp[Main](../../../samples/core/KeylessEntityTypes/Program.cs#KeylessEntityType)]

Далее мы настроим тип сущности без ключей в _OnModelCreating_ с помощью API `HasNoKey`.
Мы используем API-интерфейс конфигурации Fluent для настройки сопоставления для типа сущности без ключей:

[!code-csharp[Main](../../../samples/core/KeylessEntityTypes/Program.cs#Configuration)]

Далее мы настроим `DbContext` для включения `DbSet<T>`:

[!code-csharp[Main](../../../samples/core/KeylessEntityTypes/Program.cs#DbSet)]

Наконец можно запросить представления базы данных обычным образом:

[!code-csharp[Main](../../../samples/core/KeylessEntityTypes/Program.cs#Query)]

> [!TIP]
> Обратите внимание, что мы также определили свойство запроса уровня контекста (DbSet), которое будет использоваться в качестве корневого для запросов к этому типу.
