---
title: Типы сущностей без ключей — EF Core
author: AndriySvyryd
ms.author: ansvyryd
ms.date: 02/26/2018
ms.assetid: 9F4450C5-1A3F-4BB6-AC19-9FAC64292AAD
uid: core/modeling/keyless-entity-types
ms.openlocfilehash: e78b9f91fd2505de300ced7b5e73291b5d1ad3b4
ms.sourcegitcommit: 7bc43f21e7bdd64926314ea949aae689f1911956
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/25/2019
ms.locfileid: "71266776"
---
# <a name="keyless-entity-types"></a>Типы сущностей без ключей
> [!NOTE]
> Эта функция была добавлена в EF Core 2,1 под именем типов запросов. В EF Core 3,0 концепция была переименована в типы сущностей без ключей.

В дополнение к обычным типам сущностей модель EF Core может содержать незашифрованные _типы сущностей_, которые можно использовать для выполнения запросов к базе данных, не содержащей значений ключей.

## <a name="keyless-entity-types-characteristics"></a>Характеристики типов сущностей без ключей

Типы сущностей без ключей поддерживают многие из тех же возможностей сопоставления, что и обычные типы сущностей, такие как сопоставление наследования и свойства навигации. В реляционных хранилищах их можно настроить объекты целевой базы данных и столбцы с помощью текучего API методы или заметки к данным.

Однако они отличаются от обычных типов сущностей тем, что они:

- Ключ не может быть определен.
- Никогда не отправляются для изменений в _DbContext_ , поэтому они никогда не вставляются, не обновляются или не удаляются в базе данных.
- Никогда не обнаруживаются по соглашению.
- Поддерживаются только подмножество возможностей сопоставления навигации, в частности:
  - Они никогда не может выступать в качестве основной конец связи.
  - Они не могут иметь переходы к собственным сущностям
  - Они могут содержать только свойства навигации по ссылке, указывающие на обычные сущности.
  - Сущности не могут содержать свойства навигации для неключейых типов сущностей.
- Необходимо настроить с помощью `.HasNoKey()` вызова метода.
- Может быть сопоставлен с _определяющим запросом_. Определяющий запрос — это запрос, объявленный в модели, который выступает в качестве источника данных для типа сущности без ключей.

## <a name="usage-scenarios"></a>Сценарии использования

Ниже приведены некоторые основные сценарии использования для типов сущностей без ключей:

- Служит типом возвращаемого значения для [необработанных запросов SQL](xref:core/querying/raw-sql).
- Сопоставление с представлениями базы данных, которые не содержат первичный ключ.
- Сопоставление таблиц, у которых не определен первичный ключ.
- Сопоставление с запросами, определенными в модели.

## <a name="mapping-to-database-objects"></a>Сопоставление объектов базы данных

Сопоставление типа сущности без ключей с объектом базы данных достигается с помощью `ToTable` API `ToView` -интерфейса или Fluent. С точки зрения EF Core, является объект базы данных, указанный в этом методе _представление_, это означает, что она обрабатывается как источник запроса только для чтения и не может быть целевым объектом update, insert или delete операций. Однако это не означает, что объект базы данных действительно должен быть представлением базы данных. В качестве альтернативы можно использовать таблицу базы данных, которая будет рассматриваться как доступная только для чтения. И наоборот, для обычных типов сущностей EF Core предполагается, что объект базы данных, указанный `ToTable` в методе, может рассматриваться как _Таблица_, что означает, что он может использоваться в качестве источника запроса, но также предназначен для операций обновления, удаления и вставки. На самом деле, можно указать имя представления базы данных в `ToTable` и все должно работать нормально, пока представление настроено как обновляемые в базе данных.

> [!NOTE]
> `ToView`Предполагается, что объект уже существует в базе данных и не создается при миграции.

## <a name="example"></a>Пример

В следующем примере показано, как использовать типы сущностей без ключей для запроса представления базы данных.

> [!TIP]
> Для этой статьи вы можете скачать [пример](https://github.com/aspnet/EntityFramework.Docs/tree/master/samples/core/KeylessEntityTypes) из репозитория GitHub.

Во-первых определим простую модель блога и Post.

[!code-csharp[Main](../../../samples/core/KeylessEntityTypes/Program.cs#Entities)]

Далее мы определим представление простой базы данных, которые позволят нам запросить число сообщений, связанных с каждого блога:

[!code-csharp[Main](../../../samples/core/KeylessEntityTypes/Program.cs#View)]

Далее мы определим класс для хранения результата из представления базы данных:

[!code-csharp[Main](../../../samples/core/KeylessEntityTypes/Program.cs#KeylessEntityType)]

Далее мы настроим тип сущности без ключей в _OnModelCreating_ с помощью `HasNoKey` API.
Мы используем API-интерфейс конфигурации Fluent для настройки сопоставления для типа сущности без ключей:

[!code-csharp[Main](../../../samples/core/KeylessEntityTypes/Program.cs#Configuration)]

Далее мы настроим `DbContext` для `DbSet<T>`включения:

[!code-csharp[Main](../../../samples/core/KeylessEntityTypes/Program.cs#DbSet)]

Наконец можно запросить представления базы данных обычным образом:

[!code-csharp[Main](../../../samples/core/KeylessEntityTypes/Program.cs#Query)]

> [!TIP]
> Обратите внимание, что мы также определили свойство запроса уровня контекста (DbSet), которое будет использоваться в качестве корневого для запросов к этому типу.
