---
title: Типы сущностей без ключей — EF Core
author: AndriySvyryd
ms.author: ansvyryd
ms.date: 02/26/2018
ms.assetid: 9F4450C5-1A3F-4BB6-AC19-9FAC64292AAD
uid: core/modeling/keyless-entity-types
ms.openlocfilehash: 3dbc2700fc9bb277eb90885dfc2506c250ae21f1
ms.sourcegitcommit: 37d0e0fd1703467918665a64837dc54ad2ec7484
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/16/2019
ms.locfileid: "72445944"
---
# <a name="keyless-entity-types"></a>Типы сущностей без ключей

> [!NOTE]
> Эта функция была добавлена в EF Core 2,1 под именем типов запросов. В EF Core 3,0 концепция была переименована в типы сущностей без ключей.

В дополнение к обычным типам сущностей модель EF Core может содержать незашифрованные _типы сущностей_, которые можно использовать для выполнения запросов к базе данных, не содержащей значений ключей.

## <a name="keyless-entity-types-characteristics"></a>Характеристики типов сущностей без ключей

Типы сущностей без ключей поддерживают многие из тех же возможностей сопоставления, что и обычные типы сущностей, такие как сопоставление наследования и свойства навигации. В реляционных хранилищах они могут настраивать объекты и столбцы целевой базы данных с помощью методов API Fluent или заметок к данным.

Однако они отличаются от обычных типов сущностей тем, что они:

- Ключ не может быть определен.
- Никогда не отправляются для изменений в _DbContext_ , поэтому они никогда не вставляются, не обновляются или не удаляются в базе данных.
- Никогда не обнаруживаются по соглашению.
- Поддерживаются только подмножество возможностей сопоставления навигации, в частности:
  - Они не могут действовать в качестве основного элемента связи.
  - Они не могут иметь переходы к собственным сущностям
  - Они могут содержать только свойства навигации по ссылке, указывающие на обычные сущности.
  - Сущности не могут содержать свойства навигации для неключейых типов сущностей.
- Необходимо настроить с помощью вызова метода `.HasNoKey()`.
- Может быть сопоставлен с _определяющим запросом_. Определяющий запрос — это запрос, объявленный в модели, который выступает в качестве источника данных для типа сущности без ключей.

## <a name="usage-scenarios"></a>Сценарии использования

Ниже приведены некоторые основные сценарии использования для типов сущностей без ключей:

- Служит типом возвращаемого значения для [необработанных запросов SQL](xref:core/querying/raw-sql).
- Сопоставление с представлениями базы данных, которые не содержат первичный ключ.
- Сопоставление с таблицами, для которых не определен первичный ключ.
- Сопоставление с запросами, определенными в модели.

## <a name="mapping-to-database-objects"></a>Сопоставление с объектами базы данных

Сопоставление типа сущности с несвязанным типом с объектом базы данных достигается с помощью API-интерфейса Fluent @no__t – 0 или `ToView`. С точки зрения EF Core, объект базы данных, указанный в этом методе, является _представлением_, то есть он обрабатывается как источник запроса только для чтения и не может быть целевым объектом операций обновления, вставки или удаления. Однако это не означает, что объект базы данных действительно должен быть представлением базы данных. В качестве альтернативы можно использовать таблицу базы данных, которая будет рассматриваться как доступная только для чтения. И наоборот, для обычных типов сущностей EF Core предполагается, что объект базы данных, указанный в методе `ToTable`, может рассматриваться как _Таблица_, то есть он может использоваться в качестве источника запроса, но также предназначен для операций обновления, удаления и вставки. На самом деле можно указать имя представления базы данных в `ToTable`, и все должно работать правильно, пока представление настроено для обновления в базе данных.

> [!NOTE]
> `ToView` предполагает, что объект уже существует в базе данных и не создается при миграции.

## <a name="example"></a>Пример

В следующем примере показано, как использовать типы сущностей без ключей для запроса представления базы данных.

> [!TIP]
> Для этой статьи вы можете скачать [пример](https://github.com/aspnet/EntityFramework.Docs/tree/master/samples/core/KeylessEntityTypes) из репозитория GitHub.

Во-первых, мы определим простой блог и модель Post:

[!code-csharp[Main](../../../samples/core/KeylessEntityTypes/Program.cs#Entities)]

Далее мы определим простое представление базы данных, которое позволит запросить число записей, связанных с каждым блогом:

[!code-csharp[Main](../../../samples/core/KeylessEntityTypes/Program.cs#View)]

Далее мы определим класс для хранения результатов из представления базы данных:

[!code-csharp[Main](../../../samples/core/KeylessEntityTypes/Program.cs#KeylessEntityType)]

Далее мы настроим тип сущности без ключей в _OnModelCreating_ , используя API `HasNoKey`.
Мы используем API-интерфейс конфигурации Fluent для настройки сопоставления для типа сущности без ключей:

[!code-csharp[Main](../../../samples/core/KeylessEntityTypes/Program.cs#Configuration)]

Далее мы настроим `DbContext` для включения `DbSet<T>`:

[!code-csharp[Main](../../../samples/core/KeylessEntityTypes/Program.cs#DbSet)]

Наконец, можно запрашивать представление базы данных стандартным образом:

[!code-csharp[Main](../../../samples/core/KeylessEntityTypes/Program.cs#Query)]

> [!TIP]
> Обратите внимание, что мы также определили свойство запроса уровня контекста (DbSet), которое будет использоваться в качестве корневого для запросов к этому типу.
