---
title: Ключи (основной) — EF Core
description: Настройка ключей для типов сущностей при использовании Entity Framework Core
author: AndriySvyryd
ms.author: ansvyryd
ms.date: 11/06/2019
uid: core/modeling/keys
ms.openlocfilehash: fdaccb42259ba9dad97a05c626edd0291ca96cb0
ms.sourcegitcommit: 7a709ce4f77134782393aa802df5ab2718714479
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/04/2019
ms.locfileid: "74824624"
---
# <a name="keys-primary"></a>Ключи (первичные)

Ключ служит в качестве первичного уникального идентификатора для каждого экземпляра сущности. При использовании реляционной базы данных эта схема сопоставляется с понятием *первичного ключа*. Можно также настроить уникальный идентификатор, который не является первичным ключом (Дополнительные сведения см. в разделе [альтернативные ключи](alternate-keys.md) ).

Для настройки или создания первичного ключа можно использовать один из следующих методов.

## <a name="conventions"></a>Обозначения

По умолчанию свойство с именем `Id` или `<type name>Id` будет настроено в качестве ключа сущности.

[!code-csharp[Main](../../../samples/core/Modeling/Conventions/KeyId.cs?name=KeyId&highlight=3)]

[!code-csharp[Main](../../../samples/core/Modeling/Conventions/KeyTypeNameId.cs?name=KeyId&highlight=3)]

> [!NOTE]
> [Принадлежащие типы сущностей](xref:core/modeling/owned-entities) используют разные правила для определения ключей.

## <a name="data-annotations"></a>Заметки к данным

Заметки к данным можно использовать для настройки одного свойства в качестве ключа сущности.

[!code-csharp[Main](../../../samples/core/Modeling/DataAnnotations/KeySingle.cs?highlight=13)]

## <a name="fluent-api"></a>Текучий API

API-интерфейс Fluent можно использовать для настройки одного свойства в качестве ключа сущности.

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/KeySingle.cs?highlight=11,12)]

Можно также использовать API Fluent, чтобы настроить несколько свойств в качестве ключа сущности (называемого составным ключом). Составные ключи могут быть настроены только с помощью правил API Fluent, но не будут настраивать составной ключ, и вы не сможете использовать заметки к данным для их настройки.

[!code-csharp[Main](../../../samples/core/Modeling/FluentAPI/KeyComposite.cs?highlight=11,12)]

## <a name="key-types-and-values"></a>Типы и значения ключей

EF Core поддерживает использование свойств любого типа-примитива в качестве первичного ключа, включая `string`, `Guid`, `byte[]` и другие. Но не все базы данных поддерживают их. В некоторых случаях значения ключей можно преобразовать в поддерживаемый тип автоматически, в противном случае преобразование должно быть [указано вручную](xref:core/modeling/value-conversions).

Ключевые свойства всегда должны иметь значение, отличное от значения по умолчанию, при добавлении новой сущности в контекст, но некоторые типы будут [созданы базой данных](xref:core/modeling/generated-properties). В этом случае EF попытается создать временное значение при добавлении сущности в целях отслеживания. После вызова команды [SaveChanges](/dotnet/api/Microsoft.EntityFrameworkCore.DbContext.SaveChanges) временное значение будет заменено значением, созданным базой данных.

> [!Important]
> Если ключевое свойство имеет значение, сформированное базой данных, и при добавлении сущности указано значение, отличное от значения по умолчанию, то EF предполагает, что сущность уже существует в базе данных и попытается обновить ее вместо вставки новой. Чтобы избежать этого, не отключайте создание значений или Узнайте, [как указать явные значения для создаваемых свойств](../saving/explicit-values-generated-properties.md).