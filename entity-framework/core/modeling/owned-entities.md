---
title: Собственные типы сущностей — EF Core
author: AndriySvyryd
ms.author: ansvyryd
ms.date: 02/26/2018
ms.assetid: 2B0BADCE-E23E-4B28-B8EE-537883E16DF3
uid: core/modeling/owned-entities
ms.openlocfilehash: b2d72b08de79939904bf4e726c695440c906a8aa
ms.sourcegitcommit: 7bde8e6ad3c4565a4638646ce04bcf5e66f7b5fd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2019
ms.locfileid: "54069208"
---
# <a name="owned-entity-types"></a>Собственные типы сущностей

>[!NOTE]
> Этот компонент впервые появился в EF Core 2.0.

EF Core позволяет модели типы сущностей, которые могут появляться только когда-либо других типов сущностей свойства навигации. Они называются _собственные типы сущностей_. Сущность, содержащая принадлежащий Тип сущности является его _владельца_.

## <a name="explicit-configuration"></a>Явной настройки

Объект, к которому типы никогда не включаются по EF Core в модели по соглашению, которым владеет. Можно использовать `OwnsOne` метод в `OnModelCreating` или указать для типа `OwnedAttribute` (новое в EF Core 2.1) для настройки типа как принадлежащего типа.

В этом примере `StreetAddress` — это тип с помощью нет свойство identity. Он используется как свойство сущности Order для указания адреса доставки конкретного заказа.

Мы можем использовать `OwnedAttribute` будет считаться принадлежит сущности при обращении к от другого типа сущности:

[!code-csharp[StreetAddress](../../../samples/core/Modeling/OwnedEntities/StreetAddress.cs?name=StreetAddress)]

[!code-csharp[Order](../../../samples/core/Modeling/OwnedEntities/Order.cs?name=Order)]

Можно также использовать `OwnsOne` метод в `OnModelCreating` позволяет указать, что `ShippingAddress` свойство — это сущность принадлежит `Order` типа сущности и настроить дополнительные аспекты, при необходимости.

[!code-csharp[OwnsOne](../../../samples/core/Modeling/OwnedEntities/OwnedEntityContext.cs?name=OwnsOne)]

Если `ShippingAddress` свойство является закрытым в `Order` типа, можно использовать строковую версию `OwnsOne` метод:

[!code-csharp[OwnsOneString](../../../samples/core/Modeling/OwnedEntities/OwnedEntityContext.cs?name=OwnsOneString)]

См. в разделе [полный пример проекта](https://github.com/aspnet/EntityFramework.Docs/tree/master/samples/core/Modeling/OwnedEntities) дополнительный контекст. 

## <a name="implicit-keys"></a>Неявные ключи

Принадлежащие типы настроены `OwnsOne` или обнаруженные с помощью навигации ссылки на всегда имеют взаимно-однозначной связи с владельцем, поэтому им не нужны свои собственные значения ключа, так как значения внешних ключей являются уникальными. В предыдущем примере `StreetAddress` типа не определяет ключевое свойство.  

Чтобы понять, как EF Core отслеживает эти объекты, имеет смысл подумать, что первичный ключ создается как [затемнения свойства](xref:core/modeling/shadow-properties) для принадлежащего типа. Значение ключа экземпляра принадлежащего типа будет таким же, как значение ключа владельца экземпляра.

## <a name="collections-of-owned-types"></a>Коллекциями принадлежащих типов

>[!NOTE]
> Это новая функция в EF Core 2.2.

Чтобы настроить коллекцию принадлежащие типы `OwnsMany` должны использоваться в `OnModelCreating`. Тем не менее первичный ключ не будет настроен по соглашению, поэтому оно должно быть указано явным образом. Это часто используется сложные ключи для этих типов сущностей, включение внешний ключ к владельцу и дополнительным уникальным свойством, также может быть в состоянии тени:

[!code-csharp[OwnsMany](../../../samples/core/Modeling/OwnedEntities/OwnedEntityContext.cs?name=OwnsMany)]

## <a name="mapping-owned-types-with-table-splitting"></a>Сопоставление, принадлежащие типы с помощью разбиения таблицы

При использовании реляционных баз данных, по ссылке соглашению принадлежащие типы сопоставляются с той же таблице, как владелец. Для этого требуется разделение таблицы в двух: некоторые столбцы будут использоваться для хранения данных, владельца, а некоторые столбцы будут использоваться для хранения данных, принадлежащий сущности. Это общие возможности, известной как разделение таблицы.

> [!TIP]
> Принадлежащие типы, хранимые с помощью разбиения таблицы можно использовать аналогично сложным типам используются в EF6.

По соглашению EF Core будет имен столбцов базы данных для свойств типа принадлежащих сущностей следующий шаблон _Navigation_OwnedEntityProperty_. Таким образом `StreetAddress` свойства будут отображаться в таблице «Заказы» с именами «ShippingAddress_Street» и «ShippingAddress_City».

После добавления `HasColumnName` метод переименовать эти столбцы:

[!code-csharp[ColumnNames](../../../samples/core/Modeling/OwnedEntities/OwnedEntityContext.cs?name=ColumnNames)]

## <a name="sharing-the-same-net-type-among-multiple-owned-types"></a>Совместное использование одного типа .NET среди нескольких принадлежащие типы

Принадлежащий Тип сущности может быть того же типа .NET как другим принадлежащим типом сущности, поэтому тип .NET может оказаться недостаточно для определения принадлежащего типа.

В таких случаях свойство, указывающее от владельца принадлежащих сущностей становится _задания перехода_ типа принадлежащих сущностей. С точки зрения EF Core определяющую навигацию является частью идентификатора типа вместе с типом .NET.   

Например, в следующем классе `ShippingAddress` и `BillingAddress` имеют тот же тип .NET, `StreetAddress`:

[!code-csharp[OrderDetails](../../../samples/core/Modeling/OwnedEntities/OrderDetails.cs?name=OrderDetails)]

Чтобы понять, как EF Core позволит отличить отслеживаемые экземпляры этих объектов, может быть полезно подумать, что определение навигации стал частью ключа экземпляра со значением ключа владельца и тип .NET, принадлежащего типа.

## <a name="nested-owned-types"></a>Вложенные принадлежащие типы

В этом примере `OrderDetails` владеет `BillingAddress` и `ShippingAddress`, которые принадлежат `StreetAddress` типов. А `OrderDetails`, в свою очередь, принадлежит типу `DetailedOrder`.

[!code-csharp[DetailedOrder](../../../samples/core/Modeling/OwnedEntities/DetailedOrder.cs?name=DetailedOrder)]

[!code-csharp[OrderStatus](../../../samples/core/Modeling/OwnedEntities/OrderStatus.cs?name=OrderStatus)]

В дополнение к вложенные принадлежащие типы принадлежащий тип может ссылаться на обычной сущности, это может быть владельцем или другую сущность, до тех пор, пока принадлежащих сущностей является зависимой стороны. Эта возможность устанавливает собственные типы сущностей помимо сложных типов в EF6.

[!code-csharp[OrderDetails](../../../samples/core/Modeling/OwnedEntities/OrderDetails.cs?name=OrderDetails)]

Существует возможность цепочки `OwnsOne` метод при вызове fluent для настройки этой модели:

[!code-csharp[OwnsOneNested](../../../samples/core/Modeling/OwnedEntities/OwnedEntityContext.cs?name=OwnsOneNested)]

Это также можно добиться той же самое с использованием `OwnedAttribute` на обоих `OrderDetails` и `StreetAdress`.

## <a name="storing-owned-types-in-separate-tables"></a>Хранение принадлежащие типы в отдельных таблицах

Также в отличие от сложных типов EF6, принадлежащие типы могут храниться в отдельной таблице от владельца. Чтобы переопределить соглашение, которое сопоставляется с той же таблице, как владелец принадлежащих типов, можно просто вызвать `ToTable` и укажите другое имя таблицы. Следующий пример сопоставит `OrderDetails` и двумя адресами отдельной таблицы из `DetailedOrder`:

[!code-csharp[OwnsOneTable](../../../samples/core/Modeling/OwnedEntities/OwnedEntityContext.cs?name=OwnsOneTable)]

## <a name="querying-owned-types"></a>Запрос принадлежащие типы

При запросе владельца принадлежащие типы включаются по умолчанию. Нет необходимости использовать `Include` метод, даже если принадлежащие типы хранятся в отдельной таблице. Исходя из модели, описанной выше, следующий запрос получает `Order`, `OrderDetails` и два принадлежит `StreetAddresses` из базы данных:

[!code-csharp[DetailedOrderQuery](../../../samples/core/Modeling/OwnedEntities/Program.cs?name=DetailedOrderQuery)]

## <a name="limitations"></a>Ограничения

Некоторые из этих ограничений лежат в основе как принадлежащий рабочих типов сущности, но некоторые другие являются ограничения, что мы можно удалить в последующих выпусках:

### <a name="by-design-restrictions"></a>Ограничения нормальное поведение
- Не удается создать `DbSet<T>` для принадлежащего типа
- Нельзя вызывать `Entity<T>()` с принадлежащего типа в `ModelBuilder`

### <a name="current-shortcomings"></a>Нынешних изъянов
- Иерархии наследования, содержащие принадлежащих типов сущностей, не поддерживаются
- Справочник по переходы на принадлежащие типы сущностей не может быть null, если они явным образом сопоставлены с отдельной таблицей от владельца
- Экземпляров принадлежащих типов сущностей, которые не могут совместно использоваться несколько владельцев (это хорошо известных сценарий для объектов значений, которые не может быть реализован с помощью принадлежащих типов сущностей)

### <a name="shortcomings-in-previous-versions"></a>Недостатки в предыдущих версиях
- В EF Core 2.0 принадлежащие переходы на типы сущностей не может объявляться в производные типы сущностей, если собственные типы сущностей, явным образом сопоставляются отдельную таблицу из иерархии владельца. Это ограничение было снято в EF Core 2.1
- В EF Core 2.0 и 2.1 только одну ссылку поддерживались переходы на принадлежащие типы. Это ограничение было снято в EF Core 2.2
