---
title: Собственные типы сущностей — EF Core
author: AndriySvyryd
ms.author: ansvyryd
ms.date: 02/26/2018
ms.assetid: 2B0BADCE-E23E-4B28-B8EE-537883E16DF3
uid: core/modeling/owned-entities
ms.openlocfilehash: f69bae2de28156876e0aa57376b5dfac053adb9c
ms.sourcegitcommit: cbaa6cc89bd71d5e0bcc891e55743f0e8ea3393b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/20/2019
ms.locfileid: "71149133"
---
# <a name="owned-entity-types"></a>Собственные типы сущностей

>[!NOTE]
> Эта функция впервые реализована в EF Core 2,0.

EF Core позволяет моделировать типы сущностей, которые могут отображаться только в свойствах навигации других типов сущностей. Они называются _типами собственных сущностей_. Сущность, содержащая принадлежащий тип сущности, является ее _владельцем_.

Собственные сущности по сути являются частью владельца и не могут существовать без них, они похожи на [статистические выражения](https://martinfowler.com/bliki/DDD_Aggregate.html).

## <a name="explicit-configuration"></a>Явная конфигурация

Собственные типы сущностей никогда не включаются в EF Core в модели по соглашению. Можно использовать `OwnsOne` метод в `OnModelCreating` или добавить аннотацию к типу с `OwnedAttribute` помощью (New в EF Core 2,1), чтобы настроить тип в качестве принадлежащего типа.

В этом примере `StreetAddress` — это тип без свойства Identity. Он используется как свойство сущности Order для указания адреса доставки конкретного заказа.

Мы можем использовать, `OwnedAttribute` чтобы интерпретировать его как принадлежащую сущность при ссылке из другого типа сущности:

[!code-csharp[StreetAddress](../../../samples/core/Modeling/OwnedEntities/StreetAddress.cs?name=StreetAddress)]

[!code-csharp[Order](../../../samples/core/Modeling/OwnedEntities/Order.cs?name=Order)]

Можно также использовать `OwnsOne` метод в `OnModelCreating` , чтобы указать, что `ShippingAddress` свойство является владельцем сущности `Order` типа сущности, и настроить дополнительные аспекты при необходимости.

[!code-csharp[OwnsOne](../../../samples/core/Modeling/OwnedEntities/OwnedEntityContext.cs?name=OwnsOne)]

Если свойство является частным `Order` в типе, можно использовать строковую версию `OwnsOne` метода: `ShippingAddress`

[!code-csharp[OwnsOneString](../../../samples/core/Modeling/OwnedEntities/OwnedEntityContext.cs?name=OwnsOneString)]

См. [полный пример проекта](https://github.com/aspnet/EntityFramework.Docs/tree/master/samples/core/Modeling/OwnedEntities) для получения дополнительных контекстов. 

## <a name="implicit-keys"></a>Неявные ключи

Принадлежащие типы, `OwnsOne` настроенные или обнаруженные с помощью навигации по ссылке, всегда имеют связь «один к одному» с владельцем, поэтому им не нужны собственные значения ключей, так как значения внешних ключей уникальны. В предыдущем примере `StreetAddress` тип не требует определения ключевого свойства.  

Чтобы понять, как EF Core отслеживает эти объекты, полезно знать, что первичный ключ создается как [свойство теневого копирования](xref:core/modeling/shadow-properties) для принадлежащего типа. Значение ключа экземпляра принадлежащего типа будет таким же, как и значение ключа экземпляра Owner.

## <a name="collections-of-owned-types"></a>Коллекции принадлежащих типов

> [!NOTE]
> Это новая функция в EF Core 2.2.

Чтобы настроить коллекцию принадлежащих типов, используйте `OwnsMany` в `OnModelCreating`.

Принадлежащие типы должны иметь первичный ключ. Если в типе .NET нет хороших свойств кандидатов, EF Core может попытаться создать его. Однако если собственные типы определяются через коллекцию, достаточно просто создать свойство теневой копии, которое будет действовать как внешний ключ в качестве внешнего ключа владельца и первичный ключ принадлежащего экземпляра `OwnsOne`. Каждый владелец и, следовательно, ключ владельца недостаточно, чтобы предоставить уникальный идентификатор для каждого владельца экземпляра.

Вот два самых простых решения:
- Определение первичного ключа суррогата для нового свойства независимо от внешнего ключа, указывающего на владельца. Содержащиеся значения должны быть уникальными для всех владельцев (например, если у родителя {1} есть дочерний {1}элемент {2} , а родительский элемент не может быть дочерним {1}), поэтому значение не имеет какого-либо значения. Так как внешний ключ не является частью первичного ключа, его значения можно изменить, поэтому дочерний элемент можно переместить из одного родителя в другой, однако это обычно происходит по семантике агрегата.
- Использование внешнего ключа и дополнительного свойства в качестве составного ключа. Значение дополнительного свойства теперь должно быть уникальным только для данного родителя (поэтому {1} , если родитель имеет дочерний {1,1} элемент, родительский {2} элемент может {2,1}по-прежнему иметь дочерний элемент). Делая внешний ключ частью первичного ключа, связь между владельцем и собственной сущностью становится неизменяемой и в большей мере отражает семантику агрегата. По умолчанию это EF Core.

В этом примере мы будем использовать `Distributor` класс:

[!code-csharp[Distributor](../../../samples/core/Modeling/OwnedEntities/Distributor.cs?name=Distributor)]

По умолчанию первичным ключом, используемым для принадлежащего `ShippingCenters` типа, на который `("DistributorId", "Id")` ссылается `"DistributorId"` свойство навигации, будет `"Id"` , где — `int` FK, а — уникальное значение.

Настройка другого вызова `HasKey`PK:

[!code-csharp[OwnsMany](../../../samples/core/Modeling/OwnedEntities/OwnedEntityContext.cs?name=OwnsMany)]

> [!NOTE]
> До EF Core метод `WithOwner()` 3,0 не существовал, поэтому этот вызов следует удалить.

## <a name="mapping-owned-types-with-table-splitting"></a>Сопоставление принадлежащих типов с разделением таблицы

При использовании реляционных баз данных ссылочные типы, принадлежащие по умолчанию, сопоставляются с той же таблицей, что и владелец. Для этого требуется разделение таблицы двумя столбцами: некоторые столбцы будут использоваться для хранения данных владельца, а некоторые столбцы будут использоваться для хранения данных собственной сущности. Это обычная функция, известная как [Разбиение таблицы](table-splitting.md).

По умолчанию EF Core будет наименовать столбцы базы данных для свойств собственного типа сущности после шаблона _Navigation_OwnedEntityProperty_. `StreetAddress` Поэтому свойства будут отображаться в таблице Orders с именами ' ShippingAddress_Street ' и ' ShippingAddress_City '.

Для переименования `HasColumnName` этих столбцов можно использовать метод.

[!code-csharp[ColumnNames](../../../samples/core/Modeling/OwnedEntities/OwnedEntityContext.cs?name=ColumnNames)]

## <a name="sharing-the-same-net-type-among-multiple-owned-types"></a>Совместное использование одного типа .NET между несколькими принадлежащими типами

Принадлежащий тип сущности может иметь тот же тип .NET, что и другой принадлежащий тип сущности, поэтому тип .NET может быть недостаточно для обнаружения принадлежащего типа.

В таких случаях свойство, указывающее из владельца на принадлежащую сущность, превращается в _определяющую навигацию_ для принадлежит к типу сущности. С точки зрения EF Core, определяющая Навигация является частью удостоверения типа, рядом с типом .NET.   

Например, в следующем классе `ShippingAddress` и `BillingAddress` оба имеют одинаковый тип `StreetAddress`.NET:

[!code-csharp[OrderDetails](../../../samples/core/Modeling/OwnedEntities/OrderDetails.cs?name=OrderDetails)]

Чтобы понять, как EF Core различает отслеживание экземпляров этих объектов, можно подумать, что определяющая Навигация стала частью ключа экземпляра наряду со значением ключа владельца и типом .NET принадлежащего типа.

## <a name="nested-owned-types"></a>Вложенные принадлежащие типы

В этом примере `OrderDetails` принадлежат `BillingAddress` `ShippingAddress`и,которые являются типами.`StreetAddress` А `OrderDetails`, в свою очередь, принадлежит типу `DetailedOrder`.

[!code-csharp[DetailedOrder](../../../samples/core/Modeling/OwnedEntities/DetailedOrder.cs?name=DetailedOrder)]

[!code-csharp[OrderStatus](../../../samples/core/Modeling/OwnedEntities/OrderStatus.cs?name=OrderStatus)]

Помимо вложенных принадлежащих типов, принадлежащий тип может ссылаться на обычную сущность, он может быть либо владельцем, либо другой сущностью при условии, что принадлежащая сущность находится на зависимой стороне. Эта возможность задает собственные типы сущностей, кроме сложных типов в EF6.

[!code-csharp[OrderDetails](../../../samples/core/Modeling/OwnedEntities/OrderDetails.cs?name=OrderDetails)]

Можно связать `OwnsOne` метод в вызове Fluent, чтобы настроить эту модель:

[!code-csharp[OwnsOneNested](../../../samples/core/Modeling/OwnedEntities/OwnedEntityContext.cs?name=OwnsOneNested)]

Обратите `WithOwner` внимание на вызов, используемый для настройки свойства навигации, указывающего назад у владельца.

Результат можно получить с помощью `OwnedAttribute` как в, так `OrderDetails` и `StreetAdress`в.

## <a name="storing-owned-types-in-separate-tables"></a>Хранение принадлежащих типов в отдельных таблицах

Кроме того, в отличие от сложных типов EF6, принадлежащие типы могут храниться в отдельной таблице от владельца. Чтобы переопределить соглашение, которое сопоставляет принадлежащий тип с той же таблицей, что и владелец, можно просто вызвать метод `ToTable` и указать другое имя таблицы. В следующем примере сопоставляется `OrderDetails` и его два адреса в отдельную таблицу из `DetailedOrder`:

[!code-csharp[OwnsOneTable](../../../samples/core/Modeling/OwnedEntities/OwnedEntityContext.cs?name=OwnsOneTable)]

## <a name="querying-owned-types"></a>Запросы к собственным типам

При запросе владельца принадлежащие типы включаются по умолчанию. Не обязательно использовать `Include` метод, даже если принадлежащие типы хранятся в отдельной таблице. В зависимости от модели, описанной ранее, следующий запрос получает `Order` `OrderDetails` и два, принадлежащие `StreetAddresses` базе данных:

[!code-csharp[DetailedOrderQuery](../../../samples/core/Modeling/OwnedEntities/Program.cs?name=DetailedOrderQuery)]

## <a name="limitations"></a>Ограничения

Некоторые из этих ограничений основаны на принципах работы собственных типов сущностей, но некоторые другие являются ограничениями, которые можно удалить в следующих выпусках:

### <a name="by-design-restrictions"></a>Ограничения по проектированию
- Нельзя создать `DbSet<T>` для принадлежащего типа
- Нельзя вызвать `Entity<T>()` с собственным типом в`ModelBuilder`

### <a name="current-shortcomings"></a>Текущие недостатки
- Иерархии наследования, включающие типы собственных сущностей, не поддерживаются
- Ссылки на навигационные типы сущностей не могут иметь значение null, если они явно не сопоставлены с отдельной таблицей от владельца
- Экземпляры собственных типов сущностей не могут совместно использоваться несколькими владельцами (это хорошо известный сценарий для объектов значений, которые не могут быть реализованы с помощью собственных типов сущностей).

### <a name="shortcomings-in-previous-versions"></a>Недостатки в предыдущих версиях
- В EF Core 2,0 переходы к собственным типам сущностей не могут быть объявлены в производных типах сущностей, если только принадлежащие сущности не были явно сопоставлены с отдельной таблицей из иерархии владельца. Это ограничение было удалено в EF Core 2,1
- В EF Core 2,0 и 2,1 поддерживались только навигационные ссылки на собственные типы. Это ограничение было удалено в EF Core 2,2
