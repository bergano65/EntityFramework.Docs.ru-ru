---
title: Типы запросов — EF Core
author: anpete
ms.date: 02/26/2018
ms.assetid: 9F4450C5-1A3F-4BB6-AC19-9FAC64292AAD
uid: core/modeling/query-types
ms.openlocfilehash: 6f0f860c6a4e619e13d55e6207234a8b5261ee09
ms.sourcegitcommit: d1230e34673b8323a227ab37958dfa77f3684728
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/19/2019
ms.locfileid: "68330796"
---
# <a name="query-types"></a>Типы запросов
> [!NOTE]
> Эта функция находится в EF Core 2.1

В дополнение к типам сущностей, могут содержать модель EF Core _типы запросов_, который может использоваться для выполнения запросов к базе данных для данных, которые не сопоставлены с типами сущностей.

## <a name="compare-query-types-to-entity-types"></a>Сравнение типов запросов к типам сущностей

Типы запросов похожи на типы сущностей, в который они:

- Можно добавить в модель либо в `OnModelCreating` или с помощью свойства «набор» на производный _DbContext_.
- Поддержка множества те же возможности сопоставления, как наследование сопоставления и свойств навигации. В реляционных хранилищах их можно настроить объекты целевой базы данных и столбцы с помощью текучего API методы или заметки к данным.

Тем не менее, они отличаются от сущностей тем, что в них типы:

- Ключ должен быть определен не требуется.
- Никогда не отслеживаются для изменения на _DbContext_ и поэтому никогда не вставке, удалении или обновлении в базе данных.
- Никогда не обнаруживаются по соглашению.
- Поддерживают только подмножество возможностей навигации сопоставления — в частности:
  - Они никогда не может выступать в качестве основной конец связи.
  - Могут содержать только свойства навигации ссылки на сущности.
  - Сущности не может содержать свойства навигации к типам запросов.
- Посвящена _ModelBuilder_ с помощью `Query` метод вместо `Entity` метод.
- Сопоставляются на _DbContext_ через свойства типа `DbQuery<T>` вместо `DbSet<T>`
- Сопоставляются с объектами базы данных с помощью `ToView` метод, а не `ToTable`.
- Могут быть сопоставлены с _запроса_ — определение запроса — это дополнительный запрос, объявленные в модели, используемый источник данных для типа запроса.

## <a name="usage-scenarios"></a>Сценарии использования

Ниже приведены некоторые из основных варианта применения типы запросов.

- Выступая в качестве возвращаемого типа для нерегламентированных `FromSql()` запросов.
- Сопоставление с представлениями базы данных.
- Сопоставление таблиц, у которых не определен первичный ключ.
- Сопоставление с запросами, определенными в модели.

## <a name="mapping-to-database-objects"></a>Сопоставление объектов базы данных

Сопоставление типа запроса к объекту базы данных достигается с помощью `ToView` текучего API. С точки зрения EF Core, является объект базы данных, указанный в этом методе _представление_, это означает, что она обрабатывается как источник запроса только для чтения и не может быть целевым объектом update, insert или delete операций. Тем не менее это не означает, что объект базы данных требуется фактически быть представления базы данных - также может быть таблицей базы данных, которое будет интерпретироваться как доступный только для чтения. И наоборот, для типов сущностей, EF Core предполагает, что объект базы данных, указанные в `ToTable` метод может рассматриваться как _таблицы_, это означает, что он может использоваться как источник запроса, но также предназначено обновление, удаление и вставка операции. На самом деле, можно указать имя представления базы данных в `ToTable` и все должно работать нормально, пока представление настроено как обновляемые в базе данных.

## <a name="example"></a>Пример

В следующем примере показано, как использовать тип запроса для запроса представления базы данных.

> [!TIP]
> Для этой статьи вы можете скачать [пример](https://github.com/aspnet/EntityFramework.Docs/tree/master/samples/core/QueryTypes) из репозитория GitHub.

Во-первых определим простую модель блога и Post.

[!code-csharp[Main](../../../samples/core/QueryTypes/Program.cs#Entities)]

Далее мы определим представление простой базы данных, которые позволят нам запросить число сообщений, связанных с каждого блога:

[!code-csharp[Main](../../../samples/core/QueryTypes/Program.cs#View)]

Далее мы определим класс для хранения результата из представления базы данных:

[!code-csharp[Main](../../../samples/core/QueryTypes/Program.cs#QueryType)]

Далее мы настраиваем тип запроса в _OnModelCreating_ с помощью `modelBuilder.Query<T>` API.
Мы используем стандартную конфигурацию fluent API-интерфейсы для настройки сопоставления для типа запроса:

[!code-csharp[Main](../../../samples/core/QueryTypes/Program.cs#Configuration)]

Далее мы настроим `DbContext` для `DbQuery<T>`включения:[!code-csharp[Main](../../../samples/core/QueryTypes/Program.cs#DbQuery)]

Наконец можно запросить представления базы данных обычным образом:

[!code-csharp[Main](../../../samples/core/QueryTypes/Program.cs#Query)]

> [!TIP]
> Обратите внимание, что мы определили свойство контекста запроса уровня (DbQuery) в качестве корневого для запросов этого типа.
