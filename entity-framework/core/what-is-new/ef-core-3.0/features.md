---
title: Новые возможности в EF Core 3.0 — EF Core
author: divega
ms.date: 02/19/2019
ms.assetid: 2EBE2CCC-E52D-483F-834C-8877F5EB0C0C
uid: core/what-is-new/ef-core-3.0/features
ms.openlocfilehash: 528733d6eec33de2c9538541a6ed5be704b9d433
ms.sourcegitcommit: d01fc19aa42ca34c3bebccbc96ee26d06fcecaa2
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/16/2019
ms.locfileid: "71005555"
---
# <a name="new-features-included-in-ef-core-30"></a>Новые возможности, добавленные в EF Core 3.0

В следующем списке приведены ключевые новые функции, запланированные для реализации в EF Core 3.0.

EF Core 3.0 — основной выпуск, который также содержит многочисленные [критические изменения](xref:core/what-is-new/ef-core-3.0/breaking-changes), касающиеся улучшений API, которые могут негативно повлиять на работу существующих приложений.  

## <a name="linq-improvements"></a>Улучшения LINQ 

LINQ позволяет писать запросы к базам данных прямо в коде вашего языка программирования, используя различные типы форматированных данных, функции IntelliSense и проверку типа во время компиляции.
Однако LINQ также поддерживает написание неограниченного числа сложных запросов, содержащих произвольные выражения (вызовы методов или операции).
Обработка всех этих сочетаний всегда представляла непростую задачу для поставщиков LINQ.
В EF Core 3.0 мы переписали свою реализацию LINQ, чтобы сделать возможным преобразование на язык SQL большего количества выражений, создать эффективные запросы в большем числе случаев, предотвратить неэффективные запросы, которые остаются нераспознанными, и упростить постепенное введение новых возможностей запросов и усовершенствований производительности без нарушения работы существующих приложений и поставщиков данных.

### <a name="client-evaluation"></a>Выполнение в клиенте

Основное изменение структуры в EF Core 3.0 связано с обработкой выражений LINQ, которые не могут быть преобразованы в SQL или параметры:

В ранних версиях система EF Core просто определяла, какие части запроса можно преобразовать на язык SQL, и выполняла остальную часть запроса на клиенте.
Подобное выполнение на стороне клиента в некоторых ситуациях дает хороший результат, однако во многих случаях оно может привести к появлению неэффективных запросов.
Например, если системе EF Core 2.2 не удавалось преобразовать предикат в вызов `Where()`, она выполняла инструкцию SQL без фильтра, считывала все строки из базы данных, а затем фильтровала их в памяти.
Это может быть приемлемым при небольшом количестве строк в базе данных, но может привести к значительным проблемам с производительностью или даже сбою приложения, если база данных содержит большое число строк.
В EF Core 3.0 мы ограничили оценку клиентов, чтобы она осуществлялась только на проекции верхнего уровня (последний вызов `Select()`).
Когда система EF Core 3.0 обнаруживает выражения, которые невозможно преобразовать в любом другом месте запроса, она выдает исключение времени выполнения.

## <a name="cosmos-db-support"></a>Поддержка Cosmos DB 

Поставщик Cosmos DB для EF Core позволяет разработчикам, знакомым с моделью программирования EF, легко использовать Azure Cosmos DB в качестве базы данных приложения.
Мы хотим, чтобы такие преимущества Cosmos DB, как глобальное распределение, постоянная готовность, эластичная масштабируемость и низкая задержка, стали еще доступнее .NET-разработчикам.
Поставщик позволит использовать API-интерфейс SQL в Cosmos DB с большинством функций EF Core, включая автоматическое отслеживание изменений, LINQ и преобразование значений.

## <a name="c-80-support"></a>Поддержка C# 8.0

EF Core 3.0 использует преимущества некоторых новых возможностей C# 8.0:

### <a name="asynchronous-streams"></a>Асинхронные потоки

Асинхронные результаты запросов теперь предоставляются с помощью нового стандартного интерфейса `IAsyncEnumerable<T>` и могут использоваться с помощью `await foreach`.

``` csharp
var orders = 
  from o in context.Orders
  where o.Status == OrderStatus.Pending
  select o;

await foreach(var o in orders)
{
  Proccess(o);
} 
```

### <a name="nullable-reference-types"></a>Ссылочные типы, допускающие значение null 

Если эта новая функция включена в коде, EF Core может делать заключения о допустимости значений NULL в свойствах ссылочных типов (примитивных типов, таких как строка, или свойств навигации), чтобы принять решение о допустимости значений NULL для столбцов и связей в базе данных.

## <a name="interception"></a>Interception

Новый API перехвата в EF Core 3.0 позволяет программно наблюдать и изменять результат низкоуровневых операций с базами данных, выполняемых в рамках нормальной работы EF Core, например открытия соединений, инициации транзакций и выполнения команд. 

## <a name="reverse-engineering-of-database-views"></a>Реконструирование представлений базы данных

Типы сущностей без ключей (ранее называемые [типами запросов](xref:core/modeling/query-types)) представляют данные, которые можно прочитать базе данных, но невозможно изменить.
Благодаря этой особенности они отлично подходят для сопоставления представлений базы данных в большинстве сценариев, поэтому мы автоматизировали создание типов сущностей без ключей при реконструировании представлений базы данных.

## <a name="dependent-entities-sharing-the-table-with-the-principal-are-now-optional"></a>Зависимые сущности, имеющие общую с субъектом таблицу, теперь являются необязательными

Начиная с EF Core 3.0, если класс `OrderDetails` принадлежит классу `Order` или явно сопоставляется с той же таблицей, можно добавлять класс `Order` без класса `OrderDetails`, и все свойства `OrderDetails`, за исключением первичного ключа, будут сопоставляться со столбцами, допускающими значения NULL.

При отправке запроса EF Core задаст `OrderDetails` значение `null`, если какому-либо его обязательному свойству не задано значение или если отсутствуют необходимые свойства, помимо первичного ключа, и все свойства имеют значение `null`.

``` csharp
public class Order
{
    public int Id { get; set; }
    public int CustomerId { get; set; }
    public OrderDetails Details { get; set; }
}

[Owned]
public class OrderDetails
{
    public int Id { get; set; }
    public string ShippingAddress { get; set; }
}
```

## <a name="ef-63-on-net-core"></a>EF 6.3 на платформе .NET Core

Мы понимаем, что многие существующие приложения используют предыдущие версии EF и перенос этих приложений на EF Core исключительно для поддержки функций .NET Core может оказаться очень трудоемким.
По этой причине мы адаптировали новую версию EF 6 к работе на платформе .NET Core 3.0.
Однако имеются некоторые ограничения, например:
- Новые поставщики должны работать на .NET Core.
- Поддержка пространственных индексов в SQL Server не будет реализована.

## <a name="postponed-features"></a>Отложенные функции

Некоторые функции, первоначально запланированные для EF Core 3.0, были отложены до будущих выпусков: 

- Возможность пропускать части модели при миграции (вопрос [№ 2725](https://github.com/aspnet/EntityFrameworkCore/issues/2725)).
- Сущности контейнера свойств, которым посвящены два отдельных вопроса: [№ 9914](https://github.com/aspnet/EntityFrameworkCore/issues/9914) об общих сущностях и [№ 13610](https://github.com/aspnet/EntityFrameworkCore/issues/13610) о поддержке сопоставления индексированных свойств.
