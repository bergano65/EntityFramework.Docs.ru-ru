---
title: Ведение журнала и перехват операций базы данных — EF6
author: divega
ms.date: 10/23/2016
ms.assetid: b5ee7eb1-88cc-456e-b53c-c67e24c3f8ca
ms.openlocfilehash: be32ed114269543ac36b256a202e0494d466e4f7
ms.sourcegitcommit: c9c3e00c2d445b784423469838adc071a946e7c9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/18/2019
ms.locfileid: "68306533"
---
# <a name="logging-and-intercepting-database-operations"></a><span data-ttu-id="e6c4c-102">Ведение журнала и перехват операций базы данных</span><span class="sxs-lookup"><span data-stu-id="e6c4c-102">Logging and intercepting database operations</span></span>
> [!NOTE]
> <span data-ttu-id="e6c4c-103">**Только в EF6 и более поздних версиях**. Функции, API и другие возможности, описанные на этой странице, появились в Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-103">**EF6 Onwards Only** - The features, APIs, etc. discussed in this page were introduced in Entity Framework 6.</span></span> <span data-ttu-id="e6c4c-104">При использовании более ранней версии могут быть неприменимы некоторые или все сведения.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-104">If you are using an earlier version, some or all of the information does not apply.</span></span>  

<span data-ttu-id="e6c4c-105">Начиная с Entity Framework 6, в любое время Entity Framework отправляет команду в базу данных. Эта команда может быть перехвачена кодом приложения.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-105">Starting with Entity Framework 6, anytime Entity Framework sends a command to the database this command can be intercepted by application code.</span></span> <span data-ttu-id="e6c4c-106">Чаще всего это используется для ведения журнала SQL, но также может использоваться для изменения или отмены команды.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-106">This is most commonly used for logging SQL, but can also be used to modify or abort the command.</span></span>  

<span data-ttu-id="e6c4c-107">В частности, EF включает:</span><span class="sxs-lookup"><span data-stu-id="e6c4c-107">Specifically, EF includes:</span></span>  

- <span data-ttu-id="e6c4c-108">Свойство Log для контекста, похожее на значение DataContext. log в LINQ to SQL</span><span class="sxs-lookup"><span data-stu-id="e6c4c-108">A Log property for the context similar to DataContext.Log in LINQ to SQL</span></span>  
- <span data-ttu-id="e6c4c-109">Механизм настройки содержимого и форматирования выходных данных, отправляемых в журнал</span><span class="sxs-lookup"><span data-stu-id="e6c4c-109">A mechanism to customize the content and formatting of the output sent to the log</span></span>  
- <span data-ttu-id="e6c4c-110">Низкоуровневые стандартные блоки для перехвата, обеспечивающие более высокий уровень контроля и гибкости</span><span class="sxs-lookup"><span data-stu-id="e6c4c-110">Low-level building blocks for interception giving greater control/flexibility</span></span>  

## <a name="context-log-property"></a><span data-ttu-id="e6c4c-111">Свойство "журнал контекста"</span><span class="sxs-lookup"><span data-stu-id="e6c4c-111">Context Log property</span></span>  

<span data-ttu-id="e6c4c-112">Свойству DbContext. Database. log может быть присвоено значение Delegate для любого метода, принимающего строку.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-112">The DbContext.Database.Log property can be set to a delegate for any method that takes a string.</span></span> <span data-ttu-id="e6c4c-113">Чаще всего он используется с любым TextWriter, задавая его методу Write этого TextWriter.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-113">Most commonly it is used with any TextWriter by setting it to the “Write” method of that TextWriter.</span></span> <span data-ttu-id="e6c4c-114">Все SQL, созданные текущим контекстом, будут зарегистрированы в этом модуле записи.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-114">All SQL generated by the current context will be logged to that writer.</span></span> <span data-ttu-id="e6c4c-115">Например, следующий код выполнит запись SQL в консоль:</span><span class="sxs-lookup"><span data-stu-id="e6c4c-115">For example, the following code will log SQL to the console:</span></span>  

``` csharp
using (var context = new BlogContext())
{
    context.Database.Log = Console.Write;

    // Your code here...
}
```  

<span data-ttu-id="e6c4c-116">Обратите внимание на этот контекст. База данных. log имеет значение Console. Write.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-116">Notice that context.Database.Log is set to Console.Write.</span></span> <span data-ttu-id="e6c4c-117">Это все, что необходимо для записи SQL в консоль.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-117">This is all that is needed to log SQL to the console.</span></span>  

<span data-ttu-id="e6c4c-118">Давайте добавим простой код запроса, вставки или обновления, чтобы мы могли увидеть выходные данные:</span><span class="sxs-lookup"><span data-stu-id="e6c4c-118">Let’s add some simple query/insert/update code so that we can see some output:</span></span>  

``` csharp
using (var context = new BlogContext())
{
    context.Database.Log = Console.Write;

    var blog = context.Blogs.First(b => b.Title == "One Unicorn");

    blog.Posts.First().Title = "Green Eggs and Ham";

    blog.Posts.Add(new Post { Title = "I do not like them!" });

    context.SaveChangesAsync().Wait();
}
```  

<span data-ttu-id="e6c4c-119">При этом будут созданы следующие выходные данные:</span><span class="sxs-lookup"><span data-stu-id="e6c4c-119">This will generate the following output:</span></span>  

``` SQL
SELECT TOP (1)
    [Extent1].[Id] AS [Id],
    [Extent1].[Title] AS [Title]
    FROM [dbo].[Blogs] AS [Extent1]
    WHERE (N'One Unicorn' = [Extent1].[Title]) AND ([Extent1].[Title] IS NOT NULL)
-- Executing at 10/8/2013 10:55:41 AM -07:00
-- Completed in 4 ms with result: SqlDataReader

SELECT
    [Extent1].[Id] AS [Id],
    [Extent1].[Title] AS [Title],
    [Extent1].[BlogId] AS [BlogId]
    FROM [dbo].[Posts] AS [Extent1]
    WHERE [Extent1].[BlogId] = @EntityKeyValue1
-- EntityKeyValue1: '1' (Type = Int32)
-- Executing at 10/8/2013 10:55:41 AM -07:00
-- Completed in 2 ms with result: SqlDataReader

UPDATE [dbo].[Posts]
SET [Title] = @0
WHERE ([Id] = @1)
-- @0: 'Green Eggs and Ham' (Type = String, Size = -1)
-- @1: '1' (Type = Int32)
-- Executing asynchronously at 10/8/2013 10:55:41 AM -07:00
-- Completed in 12 ms with result: 1

INSERT [dbo].[Posts]([Title], [BlogId])
VALUES (@0, @1)
SELECT [Id]
FROM [dbo].[Posts]
WHERE @@ROWCOUNT > 0 AND [Id] = scope_identity()
-- @0: 'I do not like them!' (Type = String, Size = -1)
-- @1: '1' (Type = Int32)
-- Executing asynchronously at 10/8/2013 10:55:41 AM -07:00
-- Completed in 2 ms with result: SqlDataReader
```  

<span data-ttu-id="e6c4c-120">(Обратите внимание, что это выходная причина, при которой Инициализация базы данных уже выполнена.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-120">(Note that this is the output assuming any database initialization has already happened.</span></span> <span data-ttu-id="e6c4c-121">Если инициализация базы данных еще не была выполнена, будет выведено гораздо больше выходных данных, показывающих, что все операции миграции проводятся на условиях проверки или создания новой базы данных.)</span><span class="sxs-lookup"><span data-stu-id="e6c4c-121">If database initialization had not already happened then there would be a lot more output showing all the work Migrations does under the covers to check for or create a new database.)</span></span>  

## <a name="what-gets-logged"></a><span data-ttu-id="e6c4c-122">Что регистрируется?</span><span class="sxs-lookup"><span data-stu-id="e6c4c-122">What gets logged?</span></span>  

<span data-ttu-id="e6c4c-123">Если для свойства Log задано значение, будут занесены в журнал следующие данные:</span><span class="sxs-lookup"><span data-stu-id="e6c4c-123">When the Log property is set all of the following will be logged:</span></span>  

- <span data-ttu-id="e6c4c-124">SQL для всех различных типов команд.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-124">SQL for all different kinds of commands.</span></span> <span data-ttu-id="e6c4c-125">Например:</span><span class="sxs-lookup"><span data-stu-id="e6c4c-125">For example:</span></span>  
    - <span data-ttu-id="e6c4c-126">Запросы, включая обычные запросы LINQ, запросы eSQL и необработанные запросы из таких методов, как SqlQuery</span><span class="sxs-lookup"><span data-stu-id="e6c4c-126">Queries, including normal LINQ queries, eSQL queries, and raw queries from methods such as SqlQuery</span></span>  
    - <span data-ttu-id="e6c4c-127">Операции вставки, обновления и удаления, созданные как часть SaveChanges</span><span class="sxs-lookup"><span data-stu-id="e6c4c-127">Inserts, updates, and deletes generated as part of SaveChanges</span></span>  
    - <span data-ttu-id="e6c4c-128">Запросы на загрузку связей, например, созданные отложенной загрузкой</span><span class="sxs-lookup"><span data-stu-id="e6c4c-128">Relationship loading queries such as those generated by lazy loading</span></span>  
- <span data-ttu-id="e6c4c-129">Параметры</span><span class="sxs-lookup"><span data-stu-id="e6c4c-129">Parameters</span></span>  
- <span data-ttu-id="e6c4c-130">Выполняется ли команда асинхронно</span><span class="sxs-lookup"><span data-stu-id="e6c4c-130">Whether or not the command is being executed asynchronously</span></span>  
- <span data-ttu-id="e6c4c-131">Отметка времени, указывающая время начала исполнения команды</span><span class="sxs-lookup"><span data-stu-id="e6c4c-131">A timestamp indicating when the command started executing</span></span>  
- <span data-ttu-id="e6c4c-132">Завершилась ли команда успешно, с ошибкой, вызывая исключение или, для асинхронной операции было отменено</span><span class="sxs-lookup"><span data-stu-id="e6c4c-132">Whether or not the command completed successfully, failed by throwing an exception, or, for async, was canceled</span></span>  
- <span data-ttu-id="e6c4c-133">Указание результирующего значения</span><span class="sxs-lookup"><span data-stu-id="e6c4c-133">Some indication of the result value</span></span>  
- <span data-ttu-id="e6c4c-134">Приблизительное количество времени, затраченного на выполнение команды.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-134">The approximate amount of time it took to execute the command.</span></span> <span data-ttu-id="e6c4c-135">Обратите внимание, что это время от отправки команды для возвращения объекта результата.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-135">Note that this is the time from sending the command to getting the result object back.</span></span> <span data-ttu-id="e6c4c-136">Он не включает время на чтение результатов.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-136">It does not include time to read the results.</span></span>  

<span data-ttu-id="e6c4c-137">Просмотрев приведенный выше пример выходных данных, каждая из четырех команд записала в журнал:</span><span class="sxs-lookup"><span data-stu-id="e6c4c-137">Looking at the example output above, each of the four commands logged are:</span></span>  

- <span data-ttu-id="e6c4c-138">Запрос, полученный в результате вызова контекста. Блоги. First</span><span class="sxs-lookup"><span data-stu-id="e6c4c-138">The query resulting from the call to context.Blogs.First</span></span>  
    - <span data-ttu-id="e6c4c-139">Обратите внимание, что метод ToString для получения SQL не работал для этого запроса, так как "First" не предоставляет IQueryable для вызова ToString.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-139">Notice that the ToString method of getting the SQL would not have worked for this query since “First” does not provide an IQueryable on which ToString could be called</span></span>  
- <span data-ttu-id="e6c4c-140">Запрос, полученный в результате отложенной загрузки блога. Публиковать</span><span class="sxs-lookup"><span data-stu-id="e6c4c-140">The query resulting from the lazy-loading of blog.Posts</span></span>  
    - <span data-ttu-id="e6c4c-141">Обратите внимание на сведения о параметре для значения ключа, для которого происходит отложенная загрузка.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-141">Notice the parameter details for the key value for which lazy loading is happening</span></span>  
    - <span data-ttu-id="e6c4c-142">Регистрируются только свойства параметра, для которых заданы значения, отличные от значений по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-142">Only properties of the parameter that are set to non-default values are logged.</span></span> <span data-ttu-id="e6c4c-143">Например, свойство Size отображается только в том случае, если оно не равно нулю.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-143">For example, the Size property is only shown if it is non-zero.</span></span>  
- <span data-ttu-id="e6c4c-144">Две команды, являющиеся результатом SaveChangesAsync; один для обновления, чтобы изменить заголовок записи, другой для вставки, чтобы добавить новую запись.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-144">Two commands resulting from SaveChangesAsync; one for the update to change a post title, the other for an insert to add a new post</span></span>  
    - <span data-ttu-id="e6c4c-145">Обратите внимание на подробные сведения о параметрах для свойств FK и Title.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-145">Notice the parameter details for the FK and Title properties</span></span>  
    - <span data-ttu-id="e6c4c-146">Обратите внимание, что эти команды выполняются асинхронно.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-146">Notice that these commands are being executed asynchronously</span></span>  

## <a name="logging-to-different-places"></a><span data-ttu-id="e6c4c-147">Ведение журнала в различных местах</span><span class="sxs-lookup"><span data-stu-id="e6c4c-147">Logging to different places</span></span>  

<span data-ttu-id="e6c4c-148">Как показано выше, ведение журнала в консоли очень просто.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-148">As shown above logging to the console is super easy.</span></span> <span data-ttu-id="e6c4c-149">Кроме того, можно легко выполнять вход в память, файл и т. д., используя различные виды [TextWriter](https://msdn.microsoft.com/library/system.io.textwriter.aspx).</span><span class="sxs-lookup"><span data-stu-id="e6c4c-149">It’s also easy to log to memory, file, etc. by using different kinds of [TextWriter](https://msdn.microsoft.com/library/system.io.textwriter.aspx).</span></span>  

<span data-ttu-id="e6c4c-150">Если вы знакомы с LINQ to SQL можно заметить, что в LINQ to SQL свойству log присвоено значение фактического объекта TextWriter (например, Console. out), в то время как в EF свойству log присваивается метод, принимающий строку (например, , Console. Write или Console. out. Write).</span><span class="sxs-lookup"><span data-stu-id="e6c4c-150">If you are familiar with LINQ to SQL you might notice that in LINQ to SQL the Log property is set to the actual TextWriter object (for example, Console.Out) while in EF the Log property is set to a method that accepts a string (for example, Console.Write or Console.Out.Write).</span></span> <span data-ttu-id="e6c4c-151">Причина заключается в разделении EF из TextWriter путем приема любого делегата, который может действовать в качестве приемника для строк.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-151">The reason for this is to decouple EF from TextWriter by accepting any delegate that can act as a sink for strings.</span></span> <span data-ttu-id="e6c4c-152">Например, представьте, что у вас уже есть какая-либо платформа ведения журналов, и он определяет метод ведения журнала следующим образом:</span><span class="sxs-lookup"><span data-stu-id="e6c4c-152">For example, imagine that you already have some logging framework and it defines a logging method like so:</span></span>  

``` csharp
public class MyLogger
{
    public void Log(string component, string message)
    {
        Console.WriteLine("Component: {0} Message: {1} ", component, message);
    }
}
```  

<span data-ttu-id="e6c4c-153">Это можно подключить к свойству log в журнале EF следующим образом:</span><span class="sxs-lookup"><span data-stu-id="e6c4c-153">This could be hooked up to the EF Log property like this:</span></span>  

``` csharp
var logger = new MyLogger();
context.Database.Log = s => logger.Log("EFApp", s);
```  

## <a name="result-logging"></a><span data-ttu-id="e6c4c-154">Журнал результатов</span><span class="sxs-lookup"><span data-stu-id="e6c4c-154">Result logging</span></span>  

<span data-ttu-id="e6c4c-155">Средство ведения журнала по умолчанию регистрирует текст команды (SQL), параметры и строку "выполнение" с меткой времени перед отправкой команды в базу данных.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-155">The default logger logs command text (SQL), parameters, and the “Executing” line with a timestamp before the command is sent to the database.</span></span> <span data-ttu-id="e6c4c-156">Строка "Completed", содержащая затраченное время, регистрируется после выполнения команды.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-156">A “completed” line containing elapsed time is logged following execution of the command.</span></span>  

<span data-ttu-id="e6c4c-157">Обратите внимание, что для асинхронных команд строка "Completed" не регистрируется, пока асинхронная задача не завершается, не завершается или отменяется.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-157">Note that for async commands the “completed” line is not logged until the async task actually completes, fails, or is canceled.</span></span>  

<span data-ttu-id="e6c4c-158">Строка "завершено" содержит различные сведения в зависимости от типа команды, а также от того, завершилось ли выполнение успешно.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-158">The “completed” line contains different information depending on the type of command and whether or not execution was successful.</span></span>  

### <a name="successful-execution"></a><span data-ttu-id="e6c4c-159">Успешное выполнение</span><span class="sxs-lookup"><span data-stu-id="e6c4c-159">Successful execution</span></span>  

<span data-ttu-id="e6c4c-160">Для команд, которые успешно выполняются, выводится значение "завершено в x мс с результатом:", за которым следует указание на результат.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-160">For commands that complete successfully the output is “Completed in x ms with result: “ followed by some indication of what the result was.</span></span> <span data-ttu-id="e6c4c-161">Для команд, возвращающих модуль чтения данных, указание результата является типом возвращаемого [DbDataReader](https://msdn.microsoft.com/library/system.data.common.dbdatareader.aspx) .</span><span class="sxs-lookup"><span data-stu-id="e6c4c-161">For commands that return a data reader the result indication is the type of [DbDataReader](https://msdn.microsoft.com/library/system.data.common.dbdatareader.aspx) returned.</span></span> <span data-ttu-id="e6c4c-162">Для команд, возвращающих целочисленное значение, например, команда обновления, показанная выше, выводит это целое число.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-162">For commands that return an integer value such as the update command shown above the result shown is that integer.</span></span>  

### <a name="failed-execution"></a><span data-ttu-id="e6c4c-163">Сбой выполнения</span><span class="sxs-lookup"><span data-stu-id="e6c4c-163">Failed execution</span></span>  

<span data-ttu-id="e6c4c-164">Для команд, которые завершились ошибкой, вызывая исключение, выходные данные содержат сообщение из исключения.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-164">For commands that fail by throwing an exception, the output contains the message from the exception.</span></span> <span data-ttu-id="e6c4c-165">Например, использование SqlQuery для запроса к существующей таблице приведет к выходу журнала примерно следующего вида:</span><span class="sxs-lookup"><span data-stu-id="e6c4c-165">For example, using SqlQuery to query against a table that does exist will result in log output something like this:</span></span>  

``` SQL
SELECT * from ThisTableIsMissing
-- Executing at 5/13/2013 10:19:05 AM
-- Failed in 1 ms with error: Invalid object name 'ThisTableIsMissing'.
```  

### <a name="canceled-execution"></a><span data-ttu-id="e6c4c-166">Выполнение отменено</span><span class="sxs-lookup"><span data-stu-id="e6c4c-166">Canceled execution</span></span>  

<span data-ttu-id="e6c4c-167">Для асинхронных команд, в которых задача отменена, результат может быть неудачным с исключением, так как именно базовый поставщик ADO.NET часто выполняет попытку отмены.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-167">For async commands where the task is canceled the result could be failure with an exception, since this is what the underlying ADO.NET provider often does when an attempt is made to cancel.</span></span> <span data-ttu-id="e6c4c-168">Если это не происходит и задача отменяется без каких-либо действий, выходные данные будут выглядеть примерно так:</span><span class="sxs-lookup"><span data-stu-id="e6c4c-168">If this doesn’t happen and the task is canceled cleanly then the output will look something like this:</span></span>  

```  
update Blogs set Title = 'No' where Id = -1
-- Executing asynchronously at 5/13/2013 10:21:10 AM
-- Canceled in 1 ms
```  

## <a name="changing-log-content-and-formatting"></a><span data-ttu-id="e6c4c-169">Изменение содержимого и форматирования журнала</span><span class="sxs-lookup"><span data-stu-id="e6c4c-169">Changing log content and formatting</span></span>  

<span data-ttu-id="e6c4c-170">В разделе описывается свойство Database. log, использующее объект Датабаселогформаттер.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-170">Under the covers the Database.Log property makes use of a DatabaseLogFormatter object.</span></span> <span data-ttu-id="e6c4c-171">Этот объект эффективно привязывает реализацию Идбкоммандинтерцептор (см. ниже) к делегату, который принимает строки и DbContext.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-171">This object effectively binds an IDbCommandInterceptor implementation (see below) to a delegate that accepts strings and a DbContext.</span></span> <span data-ttu-id="e6c4c-172">Это означает, что методы в Датабаселогформаттер вызываются до и после выполнения команд с помощью EF.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-172">This means that methods on DatabaseLogFormatter are called before and after the execution of commands by EF.</span></span> <span data-ttu-id="e6c4c-173">Эти методы Датабаселогформаттер собирают и отформатируют выходные данные журнала и отправляют их делегату.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-173">These DatabaseLogFormatter methods gather and format log output and send it to the delegate.</span></span>  

### <a name="customizing-databaselogformatter"></a><span data-ttu-id="e6c4c-174">Настройка Датабаселогформаттер</span><span class="sxs-lookup"><span data-stu-id="e6c4c-174">Customizing DatabaseLogFormatter</span></span>  

<span data-ttu-id="e6c4c-175">Изменение журнала и его форматирование можно достичь, создав новый класс, производный от Датабаселогформаттер, и переопределяет методы соответствующим образом.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-175">Changing what is logged and how it is formatted can be achieved by creating a new class that derives from DatabaseLogFormatter and overrides methods as appropriate.</span></span> <span data-ttu-id="e6c4c-176">Ниже перечислены наиболее распространенные методы переопределения.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-176">The most common methods to override are:</span></span>  

- <span data-ttu-id="e6c4c-177">Логкомманд — Переопределите этот метод, чтобы изменить способ записи команд перед их выполнением.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-177">LogCommand – Override this to change how commands are logged before they are executed.</span></span> <span data-ttu-id="e6c4c-178">По умолчанию Логкомманд вызывает Логпараметер для каждого параметра; Вместо этого вы можете сделать то же самое в переопределении или обработке параметров.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-178">By default LogCommand calls LogParameter for each parameter; you may choose to do the same in your override or handle parameters differently instead.</span></span>  
- <span data-ttu-id="e6c4c-179">Логресулт — Переопределите этот параметр, чтобы изменить способ выполнения команды в журнале.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-179">LogResult – Override this to change how the outcome from executing a command is logged.</span></span>  
- <span data-ttu-id="e6c4c-180">Логпараметер — Переопределите этот параметр, чтобы изменить форматирование и содержимое журнала параметров.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-180">LogParameter – Override this to change the formatting and content of parameter logging.</span></span>  

<span data-ttu-id="e6c4c-181">Например, предположим, что мы хотим записать только одну строку перед отправкой каждой команды в базу данных.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-181">For example, suppose we wanted to log just a single line before each command is sent to the database.</span></span> <span data-ttu-id="e6c4c-182">Это можно сделать с помощью двух переопределений:</span><span class="sxs-lookup"><span data-stu-id="e6c4c-182">This can be done with two overrides:</span></span>  

- <span data-ttu-id="e6c4c-183">Переопределение Логкомманд для форматирования и записи одной строки SQL</span><span class="sxs-lookup"><span data-stu-id="e6c4c-183">Override LogCommand to format and write the single line of SQL</span></span>  
- <span data-ttu-id="e6c4c-184">Переопределите Логресулт, чтобы ничего не делать.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-184">Override LogResult to do nothing.</span></span>  

<span data-ttu-id="e6c4c-185">Код будет выглядеть примерно так:</span><span class="sxs-lookup"><span data-stu-id="e6c4c-185">The code would look something like this:</span></span>

``` csharp
public class OneLineFormatter : DatabaseLogFormatter
{
    public OneLineFormatter(DbContext context, Action<string> writeAction)
        : base(context, writeAction)
    {
    }

    public override void LogCommand<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        Write(string.Format(
            "Context '{0}' is executing command '{1}'{2}",
            Context.GetType().Name,
            command.CommandText.Replace(Environment.NewLine, ""),
            Environment.NewLine));
    }

    public override void LogResult<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
    }
}
```  

<span data-ttu-id="e6c4c-186">Чтобы журнал выводился, просто вызовите метод Write, который будет передавать выходные данные в настроенный делегат записи.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-186">To log output simply call the Write method which will send output to the configured write delegate.</span></span>  

<span data-ttu-id="e6c4c-187">(Обратите внимание, что этот код позволяет упрощенно удалить разрывы строк, как в примере.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-187">(Note that this code does simplistic removal of line breaks just as an example.</span></span> <span data-ttu-id="e6c4c-188">Скорее всего, это не будет хорошо работать при просмотре сложного SQL.)</span><span class="sxs-lookup"><span data-stu-id="e6c4c-188">It will likely not work well for viewing complex SQL.)</span></span>  

### <a name="setting-the-databaselogformatter"></a><span data-ttu-id="e6c4c-189">Настройка Датабаселогформаттер</span><span class="sxs-lookup"><span data-stu-id="e6c4c-189">Setting the DatabaseLogFormatter</span></span>  

<span data-ttu-id="e6c4c-190">После создания нового класса Датабаселогформаттер его необходимо зарегистрировать с помощью EF.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-190">Once a new DatabaseLogFormatter class has been created it needs to be registered with EF.</span></span> <span data-ttu-id="e6c4c-191">Это выполняется с помощью конфигурации на основе кода.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-191">This is done using code-based configuration.</span></span> <span data-ttu-id="e6c4c-192">В двух словах это означает создание нового класса, производного от DbConfiguration в той же сборке, что и класс DbContext, а затем вызов Сетдатабаселогформаттер в конструкторе этого нового класса.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-192">In a nutshell this means creating a new class that derives from DbConfiguration in the same assembly as your DbContext class and then calling SetDatabaseLogFormatter in the constructor of this new class.</span></span> <span data-ttu-id="e6c4c-193">Например:</span><span class="sxs-lookup"><span data-stu-id="e6c4c-193">For example:</span></span>  

``` csharp
public class MyDbConfiguration : DbConfiguration
{
    public MyDbConfiguration()
    {
        SetDatabaseLogFormatter(
            (context, writeAction) => new OneLineFormatter(context, writeAction));
    }
}
```  

### <a name="using-the-new-databaselogformatter"></a><span data-ttu-id="e6c4c-194">Использование New Датабаселогформаттер</span><span class="sxs-lookup"><span data-stu-id="e6c4c-194">Using the new DatabaseLogFormatter</span></span>  

<span data-ttu-id="e6c4c-195">Этот новый Датабаселогформаттер теперь будет использоваться в любое время в любом месте базы данных. log.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-195">This new DatabaseLogFormatter will now be used anytime Database.Log is set.</span></span> <span data-ttu-id="e6c4c-196">Таким образом, выполнение кода из части 1 приведет к следующим результатам:</span><span class="sxs-lookup"><span data-stu-id="e6c4c-196">So, running the code from part 1 will now result in the following output:</span></span>  

```  
Context 'BlogContext' is executing command 'SELECT TOP (1) [Extent1].[Id] AS [Id], [Extent1].[Title] AS [Title]FROM [dbo].[Blogs] AS [Extent1]WHERE (N'One Unicorn' = [Extent1].[Title]) AND ([Extent1].[Title] IS NOT NULL)'
Context 'BlogContext' is executing command 'SELECT [Extent1].[Id] AS [Id], [Extent1].[Title] AS [Title], [Extent1].[BlogId] AS [BlogId]FROM [dbo].[Posts] AS [Extent1]WHERE [Extent1].[BlogId] = @EntityKeyValue1'
Context 'BlogContext' is executing command 'update [dbo].[Posts]set [Title] = @0where ([Id] = @1)'
Context 'BlogContext' is executing command 'insert [dbo].[Posts]([Title], [BlogId])values (@0, @1)select [Id]from [dbo].[Posts]where @@rowcount > 0 and [Id] = scope_identity()'
```  

## <a name="interception-building-blocks"></a><span data-ttu-id="e6c4c-197">Стандартные блоки перехвата</span><span class="sxs-lookup"><span data-stu-id="e6c4c-197">Interception building blocks</span></span>  

<span data-ttu-id="e6c4c-198">До сих пор мы рассмотрели, как использовать DbContext. Database. log для ведения журнала SQL, созданного EF.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-198">So far we have looked at how to use DbContext.Database.Log to log the SQL generated by EF.</span></span> <span data-ttu-id="e6c4c-199">Но этот код на самом деле является относительно тонкой фасаднойой на некоторых низкоуровневых стандартных блоках для более общего перехвата.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-199">But this code is actually a relatively thin facade over some low-level building blocks for more general interception.</span></span>  

### <a name="interception-interfaces"></a><span data-ttu-id="e6c4c-200">Интерфейсы перехвата</span><span class="sxs-lookup"><span data-stu-id="e6c4c-200">Interception interfaces</span></span>  

<span data-ttu-id="e6c4c-201">Код перехвата построен вокруг концепции интерфейсов перехвата.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-201">The interception code is built around the concept of interception interfaces.</span></span> <span data-ttu-id="e6c4c-202">Эти интерфейсы наследуют от Идбинтерцептор и определяют методы, которые вызываются, когда EF выполняет какое – то действие.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-202">These interfaces inherit from IDbInterceptor and define methods that are called when EF performs some action.</span></span> <span data-ttu-id="e6c4c-203">Цель заключается в том, чтобы в каждом типе объекта перехватываться один интерфейс.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-203">The intent is to have one interface per type of object being intercepted.</span></span> <span data-ttu-id="e6c4c-204">Например, интерфейс Идбкоммандинтерцептор определяет методы, вызываемые перед тем, как EF выполняет вызов ExecuteNonQuery, ExecuteScalar, ExecuteReader и связанных методов.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-204">For example, the IDbCommandInterceptor interface defines methods that are called before EF makes a call to ExecuteNonQuery, ExecuteScalar, ExecuteReader, and related methods.</span></span> <span data-ttu-id="e6c4c-205">Аналогичным образом, интерфейс определяет методы, вызываемые при завершении каждой из этих операций.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-205">Likewise, the interface defines methods that are called when each of these operations completes.</span></span> <span data-ttu-id="e6c4c-206">Класс Датабаселогформаттер, который мы рассматривали выше, реализует этот интерфейс для команд журнала.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-206">The DatabaseLogFormatter class that we looked at above implements this interface to log commands.</span></span>  

### <a name="the-interception-context"></a><span data-ttu-id="e6c4c-207">Контекст перехвата</span><span class="sxs-lookup"><span data-stu-id="e6c4c-207">The interception context</span></span>  

<span data-ttu-id="e6c4c-208">Просмотр методов, определенных в любом из интерфейсов перехватчика, очевидно, что каждому вызову присваивается объект типа Дбинтерцептионконтекст или некоторый тип, производный от такого типа, как\<дбкоммандинтерцептионконтекст\>.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-208">Looking at the methods defined on any of the interceptor interfaces it is apparent that every call is given an object of type DbInterceptionContext or some type derived from this such as DbCommandInterceptionContext\<\>.</span></span> <span data-ttu-id="e6c4c-209">Этот объект содержит контекстные сведения о действии, которое принимает EF.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-209">This object contains contextual information about the action that EF is taking.</span></span> <span data-ttu-id="e6c4c-210">Например, если действие выполняется от имени DbContext, то DbContext включается в Дбинтерцептионконтекст.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-210">For example, if the action is being taken on behalf of a DbContext, then the DbContext is included in the DbInterceptionContext.</span></span> <span data-ttu-id="e6c4c-211">Аналогично, для команд, выполняемых асинхронно, флагом "Async" задано значение для Дбкоммандинтерцептионконтекст.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-211">Similarly, for commands that are being executed asynchronously, the IsAsync flag is set on DbCommandInterceptionContext.</span></span>  

### <a name="result-handling"></a><span data-ttu-id="e6c4c-212">Обработка результатов</span><span class="sxs-lookup"><span data-stu-id="e6c4c-212">Result handling</span></span>  

<span data-ttu-id="e6c4c-213">Класс дбкоммандинтерцептионконтекст\< \> содержит свойства Result, оригиналресулт, Exception и оригиналексцептион.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-213">The DbCommandInterceptionContext\<\> class contains a properties called Result, OriginalResult, Exception, and OriginalException.</span></span> <span data-ttu-id="e6c4c-214">Для вызовов методов перехвата, которые вызываются перед выполнением операции (то есть для...), для этих свойств устанавливается значение null или нуль. Выполняются методы.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-214">These properties are set to null/zero for calls to the interception methods that are called before the operation is executed — that is, for the …Executing methods.</span></span> <span data-ttu-id="e6c4c-215">Если операция выполняется и проходит успешный результат, то Result и Оригиналресулт устанавливаются в результате операции.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-215">If the operation is executed and succeeds, then Result and OriginalResult are set to the result of the operation.</span></span> <span data-ttu-id="e6c4c-216">Затем эти значения можно наблюдать в методах перехвата, которые вызываются после выполнения операции, то есть в... Выполненные методы.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-216">These values can then be observed in the interception methods that are called after the operation has executed — that is, on the …Executed methods.</span></span> <span data-ttu-id="e6c4c-217">Аналогично, если операция создает исключение, будут заданы свойства Exception и Оригиналексцептион.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-217">Likewise, if the operation throws, then the Exception and OriginalException properties will be set.</span></span>  

#### <a name="suppressing-execution"></a><span data-ttu-id="e6c4c-218">Подавление выполнения</span><span class="sxs-lookup"><span data-stu-id="e6c4c-218">Suppressing execution</span></span>  

<span data-ttu-id="e6c4c-219">Если перехватчик задает свойство Result перед выполнением команды (в одном из... Выполнение методов), то EF не будет пытаться фактически выполнить команду, но вместо этого будет использовать результирующий набор.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-219">If an interceptor sets the Result property before the command has executed (in one of the …Executing methods) then EF will not attempt to actually execute the command, but will instead just use the result set.</span></span> <span data-ttu-id="e6c4c-220">Иными словами, перехватчик может подавить выполнение команды, но элемент EF продолжит работу, как если бы команда была выполнена.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-220">In other words, the interceptor can suppress execution of the command but have EF continue as if the command had been executed.</span></span>  

<span data-ttu-id="e6c4c-221">Пример того, как это можно использовать, — пакетная обработка команд, которая традиционно была выполнена с помощью поставщика обертки.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-221">An example of how this might be used is the command batching that has traditionally been done with a wrapping provider.</span></span> <span data-ttu-id="e6c4c-222">Перехватчик сохранит команду для последующего выполнения в виде пакета, но получит EF, что команда была выполнена как нормальная.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-222">The interceptor would store the command for later execution as a batch but would “pretend” to EF that the command had executed as normal.</span></span> <span data-ttu-id="e6c4c-223">Обратите внимание, что для реализации пакетной обработки требуется больше, чем это необходимо, но это пример того, как может использоваться изменение результата перехвата.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-223">Note that it requires more than this to implement batching, but this is an example of how changing the interception result might be used.</span></span>  

<span data-ttu-id="e6c4c-224">Выполнение можно также отключить, задав свойство исключения в одном из... Выполняются методы.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-224">Execution can also be suppressed by setting the Exception property in one of the …Executing methods.</span></span> <span data-ttu-id="e6c4c-225">Это приводит к тому, что EF будет продолжать работу, как если бы выполнение операции завершилось сбоем, вызывая данное исключение.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-225">This causes EF to continue as if execution of the operation had failed by throwing the given exception.</span></span> <span data-ttu-id="e6c4c-226">Это, конечно, может привести к сбою приложения, но оно также может быть временным исключением или другим исключением, которое обрабатывается EF.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-226">This may, of course, cause the application to crash, but it may also be a transient exception or some other exception that is handled by EF.</span></span> <span data-ttu-id="e6c4c-227">Например, это можно использовать в тестовых средах для проверки поведения приложения при сбое выполнения команды.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-227">For example, this could be used in test environments to test the behavior of an application when command execution fails.</span></span>  

#### <a name="changing-the-result-after-execution"></a><span data-ttu-id="e6c4c-228">Изменение результата после выполнения</span><span class="sxs-lookup"><span data-stu-id="e6c4c-228">Changing the result after execution</span></span>  

<span data-ttu-id="e6c4c-229">Если перехватчик задает свойство Result после выполнения команды (в одном из... Выполненные методы), то EF будет использовать измененный результат вместо результата, который фактически был возвращен из операции.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-229">If an interceptor sets the Result property after the command has executed (in one of the …Executed methods) then EF will use the changed result instead of the result that was actually returned from the operation.</span></span> <span data-ttu-id="e6c4c-230">Аналогично, если перехватчик задает свойство Exception после выполнения команды, то EF вызовет исключение Set, как если бы операция вызывала исключение.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-230">Similarly, if an interceptor sets the Exception property after the command has executed, then EF will throw the set exception as if the operation had thrown the exception.</span></span>  

<span data-ttu-id="e6c4c-231">Перехватчик также может установить свойство Exception в значение null, чтобы указать, что исключение не должно выдаваться.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-231">An interceptor can also set the Exception property to null to indicate that no exception should be thrown.</span></span> <span data-ttu-id="e6c4c-232">Это может быть полезно, если выполнение операции завершилось сбоем, но перехватчик желает продолжить, как если бы операция была выполнена успешно.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-232">This can be useful if execution of the operation failed but the interceptor wishes EF to continue as if the operation had succeeded.</span></span> <span data-ttu-id="e6c4c-233">Как правило, это подразумевает задание результата, чтобы EF получил некоторое значение результата, когда оно продолжит работу.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-233">This usually also involves setting the Result so that EF has some result value to work with as it continues.</span></span>  

#### <a name="originalresult-and-originalexception"></a><span data-ttu-id="e6c4c-234">Оригиналресулт и Оригиналексцептион</span><span class="sxs-lookup"><span data-stu-id="e6c4c-234">OriginalResult and OriginalException</span></span>  

<span data-ttu-id="e6c4c-235">После того как EF выполнил операцию, она задаст свойства Result и Оригиналресулт, если выполнение не завершилось сбоем, или свойства Exception и Оригиналексцептион в случае сбоя выполнения с исключением.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-235">After EF has executed an operation it will set either the Result and OriginalResult properties if execution did not fail or the Exception and OriginalException properties if execution failed with an exception.</span></span>  

<span data-ttu-id="e6c4c-236">Свойства Оригиналресулт и Оригиналексцептион доступны только для чтения и задаются EF только после фактического выполнения операции.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-236">The OriginalResult and OriginalException properties are read-only and are only set by EF after actually executing an operation.</span></span> <span data-ttu-id="e6c4c-237">Эти свойства не могут быть заданы перехватчиками.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-237">These properties cannot be set by interceptors.</span></span> <span data-ttu-id="e6c4c-238">Это означает, что любой перехватчик может отличить исключение или результат, заданные другим перехватчиком, в отличие от реального исключения или результата, возникшего при выполнении операции.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-238">This means that any interceptor can distinguish between an exception or result that has been set by some other interceptor as opposed to the real exception or result that occurred when the operation was executed.</span></span>  

### <a name="registering-interceptors"></a><span data-ttu-id="e6c4c-239">Регистрация перехватчиков</span><span class="sxs-lookup"><span data-stu-id="e6c4c-239">Registering interceptors</span></span>  

<span data-ttu-id="e6c4c-240">После создания класса, реализующего один или несколько интерфейсов перехвата, его можно зарегистрировать в EF с помощью класса Дбинтерцептион.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-240">Once a class that implements one or more of the interception interfaces has been created it can be registered with EF using the DbInterception class.</span></span> <span data-ttu-id="e6c4c-241">Например:</span><span class="sxs-lookup"><span data-stu-id="e6c4c-241">For example:</span></span>  

``` csharp
DbInterception.Add(new NLogCommandInterceptor());
```  

<span data-ttu-id="e6c4c-242">Перехватчики также могут быть зарегистрированы на уровне домена приложения с помощью механизма конфигурации на основе кода DbConfiguration.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-242">Interceptors can also be registered at the app-domain level using the DbConfiguration code-based configuration mechanism.</span></span>  

### <a name="example-logging-to-nlog"></a><span data-ttu-id="e6c4c-243">Пример Ведение журнала в NLog</span><span class="sxs-lookup"><span data-stu-id="e6c4c-243">Example: Logging to NLog</span></span>  

<span data-ttu-id="e6c4c-244">Давайте перейдем все вместе в пример, в котором используются Идбкоммандинтерцептор и [NLog](http://nlog-project.org/) :</span><span class="sxs-lookup"><span data-stu-id="e6c4c-244">Let’s put all this together into an example that using IDbCommandInterceptor and [NLog](http://nlog-project.org/) to:</span></span>  

- <span data-ttu-id="e6c4c-245">Заносить в журнал предупреждение для любой команды, которая выполняется не асинхронно</span><span class="sxs-lookup"><span data-stu-id="e6c4c-245">Log a warning for any command that is executed non-asynchronously</span></span>  
- <span data-ttu-id="e6c4c-246">Регистрировать ошибку для любой команды, которая вызывается при выполнении</span><span class="sxs-lookup"><span data-stu-id="e6c4c-246">Log an error for any command that throws when executed</span></span>  

<span data-ttu-id="e6c4c-247">Ниже приведен класс, который выполняет ведение журнала, которое должно быть зарегистрировано, как показано выше:</span><span class="sxs-lookup"><span data-stu-id="e6c4c-247">Here’s the class that does the logging, which should be registered as shown above:</span></span>  

``` csharp
public class NLogCommandInterceptor : IDbCommandInterceptor
{
    private static readonly Logger Logger = LogManager.GetCurrentClassLogger();

    public void NonQueryExecuting(
        DbCommand command, DbCommandInterceptionContext<int> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void NonQueryExecuted(
        DbCommand command, DbCommandInterceptionContext<int> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    public void ReaderExecuting(
        DbCommand command, DbCommandInterceptionContext<DbDataReader> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void ReaderExecuted(
        DbCommand command, DbCommandInterceptionContext<DbDataReader> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    public void ScalarExecuting(
        DbCommand command, DbCommandInterceptionContext<object> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void ScalarExecuted(
        DbCommand command, DbCommandInterceptionContext<object> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    private void LogIfNonAsync<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        if (!interceptionContext.IsAsync)
        {
            Logger.Warn("Non-async command used: {0}", command.CommandText);
        }
    }

    private void LogIfError<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        if (interceptionContext.Exception != null)
        {
            Logger.Error("Command {0} failed with exception {1}",
                command.CommandText, interceptionContext.Exception);
        }
    }
}
```  

<span data-ttu-id="e6c4c-248">Обратите внимание, что этот код использует контекст перехвата, чтобы определить, когда команда выполняется не асинхронно, и определить, когда произошла ошибка при выполнении команды.</span><span class="sxs-lookup"><span data-stu-id="e6c4c-248">Notice how this code uses the interception context to discover when a command is being executed non-asynchronously and to discover when there was an error executing a command.</span></span>  
