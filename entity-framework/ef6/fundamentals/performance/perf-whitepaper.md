---
title: Рекомендации по ускорению EF4 EF5 и EF6
author: divega
ms.date: 10/23/2016
ms.assetid: d6d5a465-6434-45fa-855d-5eb48c61a2ea
ms.openlocfilehash: f8fa1001c85366e169cf50e89efdb65bd92b671e
ms.sourcegitcommit: f277883a5ed28eba57d14aaaf17405bc1ae9cf94
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/18/2019
ms.locfileid: "65874608"
---
# <a name="performance-considerations-for-ef-4-5-and-6"></a>Рекомендации по ускорению EF 4, 5 и 6
Дэвид Obando, Эрик Dettinger и другими

Дата публикации: Апрель 2012 г.

Последнее обновление: Май 2014 г.

------------------------------------------------------------------------

## <a name="1-introduction"></a>1. Вступление

Объектно-реляционное сопоставление платформ являются удобным способом для обеспечения абстрактного для доступа к данным в объектно ориентированного приложения. Для приложений .NET, что платформа Entity Framework является объектно-реляционное отображение Рекомендованное корпорацией Майкрософт. С любой абстракции, производительность может стать проблемой.

Этот технический документ был написан для отображения вопросы производительности при разработке приложений с помощью Entity Framework, чтобы предоставить разработчикам представление о внутренних алгоритмов Entity Framework, которые могут повлиять на производительность и выполнять советы для исследования и Повышение производительности в своих приложениях с помощью Entity Framework. Хороший Бернса на производительность уже доступны в Интернете, и мы постарались также указывает на эти ресурсы, где это возможно.

Производительность — это сложная тема. Этот официальный документ предназначен в качестве ресурса для внесения производительности связанные решения для приложений, использующих Entity Framework. Мы добавили некоторые показатели теста для демонстрации производительности, но эти показатели не предназначены как абсолютный показатели производительности, которое появится в вашем приложении.

С практической точки зрения в этом документе предполагается, что Entity Framework 4 выполняется в .NET 4.0 и Entity Framework 5 и 6 выполняются в .NET 4.5. Многие из улучшений производительности для Entity Framework 5 находятся в пределах основные компоненты, входящие в состав .NET 4.5.

Entity Framework 6 является готовую выпуска аппаратного контроллера управления и не зависит от компонентов Entity Framework, поставляемых вместе с .NET. Entity Framework 6 работать на .NET 4.0 и .NET 4.5, а можно позволяют оптимизировать производительность больших тем, кто еще не обновлен с .NET 4.0, но хотите последние Entity Framework в своих приложениях. При этом документе упоминается Entity Framework 6, он ссылается на последнюю версию, доступную во время написания этой статьи: версия 6.1.0.

## <a name="2-cold-vs-warm-query-execution"></a>2. "Холодных" vs. Выполнение запроса «горячего» резервирования

Первый раз, когда любой запрос выполняется к данной модели, Entity Framework выполняет массу работы за кулисами для загрузки и проверки модели. Мы часто ссылаются на этот первый запрос как запрос на «холодный».  Дальнейшие запросы к модели уже загруженный известны как «горячего» резервирования запросов и выполняется гораздо быстрее.

Давайте высокоуровневое представление расходуется время при выполнении запроса с помощью Entity Framework и см. в разделе, где постоянно улучшаем вещи в Entity Framework 6.

**Выполнение первого запроса — "холодных" запрос**

| Код записывает пользователя                                                                                     | Действие                    | EF4 Влияние на производительность                                                                                                                                                                                                                                                                                                                                                                                                        | EF5 Влияние на производительность                                                                                                                                                                                                                                                                                                                                                                                                                                                    | EF6 Влияние на производительность                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|:-----------------------------------------------------------------------------------------------------|:--------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `using(var db = new MyContext())` <br/> `{`                                                          | Создание контекста          | Средняя                                                                                                                                                                                                                                                                                                                                                                                                                        | Средняя                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Low                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `  var q1 = ` <br/> `    from c in db.Customers` <br/> `    where c.Id == id1` <br/> `    select c;` | Создание выражения запроса | Low                                                                                                                                                                                                                                                                                                                                                                                                                           | Low                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Low                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `  var c1 = q1.First();`                                                                             | Выполнение запроса LINQ      | -Загрузка метаданных: Высокий уровень, но кэшированные <br/> — Просмотр поколения: Потенциально в очень высокой, но кэшированные <br/> -Параметр ознакомительная версия: Средняя <br/> -Преобразования запроса: Средняя <br/> -Создание материализатора: Средний, но кэшированные <br/> -Выполнение запроса базы данных: Может иметь значительные <br/> + Connection.Open <br/> + Command.ExecuteReader <br/> + DataReader.Read <br/> Материализация объектов: Средняя <br/> -Поиск identity: Средняя | -Загрузка метаданных: Высокий уровень, но кэшированные <br/> — Просмотр поколения: Потенциально в очень высокой, но кэшированные <br/> -Параметр ознакомительная версия: Low <br/> -Преобразования запроса: Средний, но кэшированные <br/> -Создание материализатора: Средний, но кэшированные <br/> -Выполнение запроса базы данных: Может иметь значительные (запросы, в некоторых ситуациях лучше) <br/> + Connection.Open <br/> + Command.ExecuteReader <br/> + DataReader.Read <br/> Материализация объектов: Средняя <br/> -Поиск identity: Средняя | -Загрузка метаданных: Высокий уровень, но кэшированные <br/> — Просмотр поколения: Средний, но кэшированные <br/> -Параметр ознакомительная версия: Low <br/> -Преобразования запроса: Средний, но кэшированные <br/> -Создание материализатора: Средний, но кэшированные <br/> -Выполнение запроса базы данных: Может иметь значительные (запросы, в некоторых ситуациях лучше) <br/> + Connection.Open <br/> + Command.ExecuteReader <br/> + DataReader.Read <br/> Материализация объектов: Средний (быстрее, чем EF5) <br/> -Поиск identity: Средняя |
| `}`                                                                                                  | Connection.Close          | Low                                                                                                                                                                                                                                                                                                                                                                                                                           | Low                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Low                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |


**Выполнение запроса, второй — «теплого» запроса**

| Код записывает пользователя                                                                                     | Действие                    | EF4 Влияние на производительность                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | EF5 Влияние на производительность                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | EF6 Влияние на производительность                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|:-----------------------------------------------------------------------------------------------------|:--------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `using(var db = new MyContext())` <br/> `{`                                                          | Создание контекста          | Средняя                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Средняя                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Low                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `  var q1 = ` <br/> `    from c in db.Customers` <br/> `    where c.Id == id1` <br/> `    select c;` | Создание выражения запроса | Low                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Low                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Low                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `  var c1 = q1.First();`                                                                             | Выполнение запроса LINQ      | -Metadata ~~Загрузка~~ подстановки: ~~Высокий уровень, но кэшированных~~ низкий <br/> — Просмотр ~~поколения~~ подстановки: ~~Потенциально очень высокой, но кэшированных~~ низкий <br/> -Параметр ознакомительная версия: Средняя <br/> -Query ~~перевода~~ подстановки: Средняя <br/> -Материализатора ~~поколения~~ подстановки: ~~Среднего размера, но кэшированных~~ низкий <br/> -Выполнение запроса базы данных: Может иметь значительные <br/> + Connection.Open <br/> + Command.ExecuteReader <br/> + DataReader.Read <br/> Материализация объектов: Средняя <br/> -Поиск identity: Средняя | -Metadata ~~Загрузка~~ подстановки: ~~Высокий уровень, но кэшированных~~ низкий <br/> — Просмотр ~~поколения~~ подстановки: ~~Потенциально очень высокой, но кэшированных~~ низкий <br/> -Параметр ознакомительная версия: Low <br/> -Query ~~перевода~~ подстановки: ~~Среднего размера, но кэшированных~~ низкий <br/> -Материализатора ~~поколения~~ подстановки: ~~Среднего размера, но кэшированных~~ низкий <br/> -Выполнение запроса базы данных: Может иметь значительные (запросы, в некоторых ситуациях лучше) <br/> + Connection.Open <br/> + Command.ExecuteReader <br/> + DataReader.Read <br/> Материализация объектов: Средняя <br/> -Поиск identity: Средняя | -Metadata ~~Загрузка~~ подстановки: ~~Высокий уровень, но кэшированных~~ низкий <br/> — Просмотр ~~поколения~~ подстановки: ~~Среднего размера, но кэшированных~~ низкий <br/> -Параметр ознакомительная версия: Low <br/> -Query ~~перевода~~ подстановки: ~~Среднего размера, но кэшированных~~ низкий <br/> -Материализатора ~~поколения~~ подстановки: ~~Среднего размера, но кэшированных~~ низкий <br/> -Выполнение запроса базы данных: Может иметь значительные (запросы, в некоторых ситуациях лучше) <br/> + Connection.Open <br/> + Command.ExecuteReader <br/> + DataReader.Read <br/> Материализация объектов: Средний (быстрее, чем EF5) <br/> -Поиск identity: Средняя |
| `}`                                                                                                  | Connection.Close          | Low                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Low                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Low                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |


Существует несколько способов, позволяющих сократить стоимость производительности запросов "холодных" и "горячего" резервирования, и мы рассмотрим в следующем разделе. В частности мы рассмотрим снижая затраты на загрузку в "холодных" запросы с помощью заранее созданные представления, которые должны помочь устранить трудности производительности, возникшие во время создания представления модели. Для "горячего" резервирования запросов мы обсудим кэширование планов запросов, запросы без отслеживания и параметры выполнения другой запрос.

### <a name="21-what-is-view-generation"></a>2.1. что такое создание представлений

Чтобы понять, какое представление сформирован, нам необходимо сначала понять, каковы «Сопоставление представлений». Сопоставление представления — это исполняемый файл представления преобразований, указанных в сопоставлении для каждого набора сущностей и ассоциаций. На внутреннем уровне эти представления сопоставления принимать форму CQTs (деревья каноническую запроса). Существует два типа представлений сопоставления:

-   Отправить запрос представлений: они представляют собой преобразования, необходимо вернуться в схеме базы данных в концептуальную модель.
-   Обновление представлений: они представляют собой преобразований, необходимых для перехода из концептуальной модели со схемой базы данных.

Имейте в виду, что концептуальной модели может отличаться от схемы базы данных различными способами. Например один из одной таблицы может использоваться для хранения данных для двух разных типов сущностей. Наследование и без того нетривиальные сопоставления играют роль в сложности сопоставления представления.

Процесс вычисления эти представления, на основе спецификации сопоставления так называемый средств создания представления. Создание представлений может либо выполняться динамически при загрузке модели или во время сборки с помощью «заранее сформированные представления»; Последнее, сериализуются в виде инструкций Entity SQL для C\# или VB-файл.

При создании представления, они также проверяются. С точки зрения производительности большинство стоимость создания представления является фактически проверки представлений, что гарантирует смысла соединений между сущностями и иметь правильную кратность для всех поддерживаемых операций.

При выполнении запроса через набор сущностей, запрос объединяется с соответствующее представление запроса, а результат этой композиции выполняется через план компилятору создавать представление запроса, который может понять резервного хранилища. Для SQL Server конечным результатом компиляции будет инструкцию T-SQL SELECT. В первый раз выполняется обновление через набор сущностей, сходную процедуру для преобразования его в инструкции DML для целевой базы данных выполняется обновление представления.

### <a name="22-factors-that-affect-view-generation-performance"></a>2.2 факторы, влияющие на производительность создания представления

Производительность этапа формирования представления, не только, зависит от размер вашей модели, но и о том, как взаимосвязанных модели. Если две сущности подключены по цепочке наследования или ассоциации, они называются должен быть подключен. Аналогичным образом, если две таблицы связаны с помощью внешнего ключа, они подключены. Как увеличить количество подключенных сущностями и таблицами в схемах, средств создания представления плата увеличивается.

Алгоритм, который используется для создания и проверки представления экспоненциального в худшем случае, хотя мы используем некоторые оптимизации для улучшения качества. Ниже приведены крупнейших фактора, которые могут отрицательно повлиять на производительность.

-   Размер модели, ссылка на число сущностей и объем ассоциации между этими сущностями.
-   Модель сложности, в частности наследования, включающих большое число типов.
-   С помощью независимых сопоставлений вместо внешнего ключа ассоциации.

Для моделей небольшие, простые стоимость может быть достаточно небольшим, чтобы не возиться с помощью заранее сформированные представления. Как увеличить размер модели и сложности, существует несколько вариантов, доступных для сокращения затрат на создание представлений и проверки.

### <a name="23-using-pre-generated-views-to-decrease-model-load-time"></a>Время загрузки 2,3 Pre-Generated представлениями для уменьшения модели

Подробные сведения о том, как использовать заранее созданные представления Entity Framework 6 [Pre-Generated сопоставление представлений](~/ef6/fundamentals/performance/pre-generated-views.md)

#### <a name="231-pre-generated-views-using-the-entity-framework-power-tools-community-edition"></a>2.3.1 заранее сформированные представления, с помощью Entity Framework Power Tools Community Edition

Можно использовать [Entity Framework 6 Power Tools Community Edition](https://marketplace.visualstudio.com/items?itemName=ErikEJ.EntityFramework6PowerToolsCommunityEdition) для создания представлений моделей EDMX и Code First, щелкнув правой кнопкой мыши файл класса модели и выберите «Создание представления» с помощью меню Entity Framework. Entity Framework Power Tools Community Edition работают только с производным DbContext контекстов.

#### <a name="232-how-to-use-pre-generated-views-with-a-model-created-by-edmgen"></a>2.3.2 как использовать заранее созданные представления с помощью модели, созданные EDMGen

EDMGen — это служебная программа, которая поставляется с .NET и работает с Entity Framework 4 и 5, но не с Entity Framework 6. EDMGen позволяет создавать файл модели, на уровне объектов и представления из командной строки. Один из выходов появится файл представления на языке программирования, Visual Basic или C\#. Это файл кода, содержащий фрагменты Entity SQL для каждого набора сущностей. Чтобы включить заранее созданные представления, просто включите файл в проекте.

Если вы вручную редактировать файлы схемы для модели, необходимо будет повторно создать файл представления. Это можно сделать, выполнив EDMGen с **/mode:ViewGeneration** флаг.

#### <a name="233-how-to-use-pre-generated-views-with-an-edmx-file"></a>2.3.3 способы использования представления Pre-Generated с EDMX-файла

EDMGen также можно использовать для создания представлений для EDMX-файла — ранее указанной статьи MSDN описывается добавление события перед сборкой, чтобы сделать это — но ситуация осложняется и существуют случаи, где невозможно. Обычно проще использовать шаблон T4 для создания представления, когда модель находится в EDMX-файла.

Блог группы ADO.NET имеет post, в котором описано, как использовать шаблон T4 для создания представлений ( \<http://blogs.msdn.com/b/adonet/archive/2008/06/20/how-to-use-a-t4-template-for-view-generation.aspx>). Эта запись включает в себя шаблон, который можно загрузить и добавлен в проект. Шаблон был написан для первой версии Entity Framework, поэтому они не обязательно работают с последними версиями платформы Entity Framework. Тем не менее можно загрузить набор быстрее получать новые шаблоны создания представления для Entity Framework 4 и 5from коллекции Visual Studio:

-   VB.NET: \<http://visualstudiogallery.msdn.microsoft.com/118b44f2-1b91-4de2-a584-7a680418941d>
-   C\#: \<http://visualstudiogallery.msdn.microsoft.com/ae7730ce-ddab-470f-8456-1b313cd2c44d>

Если вы используете Entity Framework 6 представления можно получить шаблоны создания T4 из коллекции Visual Studio в \<http://visualstudiogallery.msdn.microsoft.com/18a7db90-6705-4d19-9dd1-0a6c23d0751f>.

### <a name="24-reducing-the-cost-of-view-generation"></a>2.4, снижая затраты средств создания представления

Используя заранее созданные представления перемещает затраты на создание представлений из модели загрузки (времени выполнения) время разработки. Хотя это улучшает производительность при запуске во время выполнения, будут по-прежнему возникают усилий, затрачиваемых на создание представлений при разработке. Существует несколько дополнительных приемов, которые могут помочь снизить затраты на создание представлений, как во время компиляции и выполнения.

#### <a name="241-using-foreign-key-associations-to-reduce-view-generation-cost"></a>2.4.1 с помощью внешнего ключа ассоциации, чтобы сократить затраты на создание представления

Мы видели несколько ситуаций, где переключение ассоциации в модели, из независимых сопоставлений для внешнего ключа ассоциации значительно улучшена время, затраченное на создание представлений.

Чтобы продемонстрировать это улучшение, мы создания двух версий модели Navision EDMGen. *Примечание: см. в приложении C для описания модели Navision.* Модель Navision представляет интерес для этого упражнения из-за его очень большой объем сущностей и связей между ними.

Одна версия этой очень большой модели был создан с помощью ассоциации внешних ключей и другой был сформирован с использованием независимых сопоставлений. Мы затем истекло время ожидания как долго длилось ее для создания представлений для каждой модели. Entity Framework 5 теста используется метод GenerateViews() из класса EntityViewGenerator для создания представления, при работе с Entity Framework 6 тестовый метод GenerateViews() из класса StorageMappingItemCollection. Это из-за кода реструктуризации, произошедшего в базе кода Entity Framework 6.

С помощью Entity Framework 5, средств создания представления для модели с внешними ключами заняло 65 минут на машине лаборатории. Нет сколько времени потребовалось бы, чтобы создать представления для модели, используемые независимых сопоставлений. Мы оставили тест будет выполняться более одного месяца, прежде чем компьютер был перезагружен в нашей лаборатории, чтобы установить ежемесячных обновлений.

С помощью Entity Framework 6, средств создания представления для модели с внешними ключами занял 28 секунд в том же компьютере лаборатории. Создание представлений для модели, который использует независимых сопоставлений заняло 58 секунд. Повышение для Entity Framework 6 на его просмотр создания кода означает, что многие проекты не нужно заранее сформированные представления для получения более быстрое время запуска.

Очень важно замечание, что предварительное создание представлений в Entity Framework 4 и 5 можно сделать с помощью EDMGen или Entity Framework Power Tools. Для представления Entity Framework 6 создания можно с помощью Entity Framework Power Tools или программными средствами, как описано в разделе [Pre-Generated сопоставления представлений](~/ef6/fundamentals/performance/pre-generated-views.md).

##### <a name="2411-how-to-use-foreign-keys-instead-of-independent-associations"></a>2.4.1.1 как использовать внешние ключи, вместо независимых сопоставлений

При использовании EDMGen или Entity Designer в Visual Studio, вы получаете внешних ключей по умолчанию, и только у одного флажка или командной строки флага для переключения между внешних ключей и IAs.

Если у вас есть большой модели Code First, с помощью независимых сопоставлений будет иметь такое же влияние на средств создания представления. Это влияние можно избежать, включая свойства внешнего ключа в классах для зависимых объектов, хотя некоторые разработчики рассматривает его как избавляют их объектная модель. Можно найти дополнительные сведения по этой теме в \<http://blog.oneunicorn.com/2011/12/11/whats-the-deal-with-mapping-foreign-keys-using-the-entity-framework/>.

| В языке      | Сделайте следующее                                                                                                                                                                                                                                                                                                                              |
|:----------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Entity Designer | После добавления ассоциацию между двумя сущностями, убедитесь, что у вас есть справочного ограничения. Ссылочные ограничения сообщить Entity Framework для использования внешних ключей вместо независимых сопоставлений. Для получения дополнительных сведений посетите \<http://blogs.msdn.com/b/efdesign/archive/2009/03/16/foreign-keys-in-the-entity-framework.aspx>. |
| EDMGen          | При использовании EDMGen для формирования файлов из базы данных, внешние ключи, все доступные и добавляются в модель таким образом. Дополнительные сведения о различных параметрах, предоставляемыми EDMGen [http://msdn.microsoft.com/library/bb387165.aspx](https://msdn.microsoft.com/library/bb387165.aspx).                           |
| Code First      | См. в разделе «Соглашение о связи» [первый соглашения о коде](~/ef6/modeling/code-first/conventions/built-in.md) сведения о том, как включить свойства внешнего ключа для зависимых объектов при использовании Code First.                                                                                              |

#### <a name="242-moving-your-model-to-a-separate-assembly"></a>2.4.2 перемещение модели в отдельной сборке

Когда модели включается непосредственно в проект приложения и создать представления через событие перед построением или шаблон T4, средств создания представления и проверка будет выполняться каждый раз, когда проект будет перестроен, даже если модель не была изменена. Если вы перемещаете модель в отдельную сборку и сослаться на него из проекта приложения, внесения других изменений в приложение без необходимости перестроения проекта, содержащего модель.

*Примечание:*  при перемещении модели в отдельные сборки не забудьте скопировать строки подключения для модели в файле конфигурации клиентского проекта.

#### <a name="243-disable-validation-of-an-edmx-based-model"></a>2.4.3 отключите проверку модели на основе edmx

Модели EDMX проверяются во время компиляции, даже если модель не содержит изменений. Если модель уже проверены, их можно отключить проверки во время компиляции, задав свойство «Проверка при сборке» значение false в окне «Свойства». При изменении сопоставления или модели, вы можете временно повторно включить проверки, чтобы проверить внесенные изменения.

Обратите внимание, что внесены улучшения производительности в конструкторе Entity Framework для Entity Framework 6 «проверка при сборке» обходится намного ниже, чем в предыдущих версиях конструктора.

## <a name="3-caching-in-the-entity-framework"></a>3 кэширования на платформе Entity Framework

Платформа Entity Framework должна кэширования встроенных следующих форм:

1.  Кэширование объектов — ObjectStateManager, встроенные в экземпляр ObjectContext отслеживает в памяти объектов, которые были получены с помощью этого экземпляра. Это также называется кэш первого уровня.
2.  Запрос кэширование плана — повторное использование команды созданный, когда запрос выполняется более одного раза.
3.  Метаданные, кэширование — совместное использование разных способа подключения к той же модели метаданных для модели.

Помимо кэши, предоставляет EF по умолчанию, это специальный поставщик данных ADO.NET, известных как поставщик упаковки также может использоваться для расширения Entity Framework с кэшем результатов, полученных из базы данных, также известный как кэширование второго уровня.

### <a name="31-object-caching"></a>3.1 кэширование объектов

По умолчанию когда сущность возвращается в результатах запроса, непосредственно перед EF материализует, ObjectContext проверяет, если сущность с таким ключом уже были загружены в его ObjectStateManager. Если сущность с помощью тех же самых ключей уже существует EF будет включить в результаты запроса. Несмотря на то, что EF по-прежнему будет выдавать запрос к базе данных, это поведение можно работать в обход большей стоимости материализация сущности несколько раз.

#### <a name="311-getting-entities-from-the-object-cache-using-dbcontext-find"></a>3.1.1 Получение сущности из объекта кэша с помощью метода DbContext Find

В отличие от обычных запросов метод Find в DbSet (интерфейсов API, включенных в первый раз, в EF 4.1) выполнит поиск в памяти перед даже выдачей запроса к базе данных. Важно отметить, что два разных экземпляра ObjectContext будет иметь два разных экземпляров ObjectStateManager, это означает, что они имеют отдельный объект кэша.

Поиск использует значение первичного ключа попытку найти сущность, отслеживаемые по контексту. Если сущность не находится в контексте затем запрос будет выполнен и вычисляется в базе данных и возвращается значение null, если сущность не найдена в контексте или в базе данных. Обратите внимание, что найти также возвращает сущности, которые были добавлены в контекст, но еще не были сохранены в базе данных.

Есть вопросы производительности, которые должны выполняться при с помощью метода Find. Вызовы этого метода по умолчанию активирует проверку кэша объектов для обнаружения изменения, ожидающие выполнения фиксации к базе данных. Этот процесс может быть очень дорогим в том случае, если существует большое количество объектов в кэше объектов или в виде графа больших объектов, добавляемый в кэш объектов, но также может быть отключена. В некоторых случаях может заметить на порядок разницы в вызов Find, метод, при отключении автоматического обнаружения изменений. Еще второго порядка воспринимается, когда объект фактически соотношения когда объект должен быть извлечен из базы данных. Ниже приведен пример графа, с помощью изменений, выполненных с помощью некоторые из наших микротестами, выраженный в миллисекундах, с нагрузкой 5000 сущностей.

![Логарифмическая шкала .NET 4.5](~/ef6/media/net45logscale.png ".NET 4.5 - логарифмической шкалы")

Ниже приведен пример поиска с изменениями автоопределения отключена.

``` csharp
    context.Configuration.AutoDetectChangesEnabled = false;
    var product = context.Products.Find(productId);
    context.Configuration.AutoDetectChangesEnabled = true;
    ...
```

Что необходимо учитывать при использовании метода Find является:

1.  Если объект не находится в кэше преимущества поиска отрицательное, но синтаксис по-прежнему проще, чем запрос по ключу.
2.  Включено ли автоматическое обнаружение изменений может увеличиться стоимость метод Find один порядок или более в зависимости от сложности модели и количество сущностей в объект кэша.

Кроме того Имейте в виду, что найти только возвращает сущность, которую вы ищете, и он не автоматически загружает его связанные сущности, если они отсутствуют в кэше объектов. Если вам необходимо получить связанные сущности, можно использовать запрос по ключу с безотлагательной загрузкой. Дополнительные сведения см. в разделе **8.1 vs отложенной загрузки. Безотложная загрузка**.

#### <a name="312-performance-issues-when-the-object-cache-has-many-entities"></a>3.1.2 производительностью, когда кэш объектов большим количеством сущностей

Кэш объектов позволяет увеличить общую скорость реагирования Entity Framework. Тем не менее при кэша объектов имеет очень большой объем сущностей, загрузки, это может повлиять на некоторые операции, такие как добавление, удаление, найти запись, SaveChanges и многое другое. В частности операции, вызывающие вызов DetectChanges отрицательно повлияет кэши очень большой объект. Метод DetectChanges синхронизирует граф объекта с диспетчер состояния объекта и его обеспечивает производительность, напрямую зависит от размера графа объектов. Дополнительные сведения о DetectChanges, см. в разделе [отслеживание изменений в сущностях POCO](https://msdn.microsoft.com/library/dd456848.aspx).

При использовании Entity Framework 6, разработчики имеют возможность вызвать AddRange и RemoveRange непосредственно в DbSet, вместо итерации по коллекции и вызова Add один раз на каждый экземпляр. С помощью методов диапазон удобен тем, что стоимость DetectChanges выплачивается только один раз для всего набора сущностей, а не один раз в каждой сущности, добавляемого.

### <a name="32-query-plan-caching"></a>3.2 кэширование плана запросов

Запрос выполняется, впервые проходит внутренний план компилятору преобразовать концептуальные запрос в команду хранилища (например, T-SQL выполняется при выполнении SQL-сервере).  Если включено кэширование планов запросов, в следующий раз, запрос будет выполнен хранилище команда получаются непосредственно из кэша планов запросов для выполнения, минуя компилятора плана.

Кэша планов запросов совместно используется экземплярами ObjectContext в том же домене приложения. Не нужно удерживать экземпляр ObjectContext можно было использовать кэширование планов запросов.

#### <a name="321-some-notes-about-query-plan-caching"></a>3.2.1 некоторые замечания о планировании кэширование запросов

-   Кэш планов запроса является общим для всех типов запросов: Язык Entity SQL, LINQ to Entities и объекты CompiledQuery.
-   По умолчанию кэширование планов запросов включена для запросов Entity SQL, выполнения с помощью EntityCommand или с помощью ObjectQuery. Он также включается по умолчанию для LINQ для запросов сущностей в Entity Framework в .NET 4.5, а в Entity Framework 6
    -   Кэширование плана запроса можно отключить, задав свойство EnablePlanCaching (на EntityCommand или ObjectQuery) значение false. Пример:
``` csharp
                    var query = from customer in context.Customer
                                where customer.CustomerId == id
                                select new
                                {
                                    customer.CustomerId,
                                    customer.Name
                                };
                    ObjectQuery oQuery = query as ObjectQuery;
                    oQuery.EnablePlanCaching = false;
```
-   Для параметризованных запросов изменив значение параметра по-прежнему достигнет кэшированных запросов. Но изменение аспекты параметров (например, размер, точность или масштаб) достигнет другую запись в кэше.
-   При использовании Entity SQL, строка запроса является частью ключа. Все изменения запроса приведет к записи кэша, даже если запросы функционально эквивалентны. Сюда входят изменения регистра или пробел.
-   При использовании LINQ, запрос обрабатывается для создания частью ключа. Изменение выражения LINQ таким образом создаст другой ключ.
-   Другие технические ограничения могут применяться; Дополнительные сведения см. Autocompiled запросов.

#### <a name="322-cache-eviction-algorithm"></a>3.2.2 алгоритм вытеснения кэша

Понимание того, как работает внутренняя алгоритм поможет выяснить, чтобы включить или отключить кэширование плана запроса. Алгоритм очистки выглядит следующим образом:

1.  Когда кэш содержит определенный набор записей (800), мы начнем таймер, периодически (один раз в минуту) выполняет очистку кэша.
2.  Во время переходов кэша записи удаляются из кэша на LFRU (наименее часто — недавно использованные) основы. Этот алгоритм учитывает число попаданий и возраст решая, какие операции, исключаются из кэша.
3.  В конце каждого Очистка кэша кэш снова содержит 800 записей.

Все записи кэша обрабатываются одинаково, определяя, какие операции удаления. Это означает, что команда хранилища для CompiledQuery имеет вероятностью вытеснения, как команда хранилища для запроса Entity SQL.

Обратите внимание, что в запускается таймер вытеснения кэша, при наличии 800 сущностей в кэше, но кэш только лежит 60 секунд после запуска этого таймера. Это означает, что до 60 секунд кэша может увеличиваться достаточно большие.

#### <a name="323-test-metrics-demonstrating-query-plan-caching-performance"></a>3.2.3 проверить метрики, демонстрация производительности кэширования плана запроса

Чтобы продемонстрировать влияние на производительность приложения кэширование плана запроса, мы выполнили теста где мы выполним несколько запросов Entity SQL к модели Navision. См. в приложении описание модели Navision и типы запросов, которые были выполнены. В этом тесте мы сначала итерацию по списку запросов и выполнения каждого из них один раз для добавления их в кэш (если включено кэширование). Этот шаг является untimed. Далее мы спящий режим главного потока для более чем 60 секунд разрешить кэшировать широкими вступили в силу; Наконец выполняется перебор списка второй время выполнения кэшированные запросы. Кроме того перед выполнением каждого набора запросов, чтобы случаи, когда мы получаем точно отражают преимуществ, предоставляемых кэша планов запросов, при сбросе кэша плана SQL Server.

##### <a name="3231-test-results"></a>3.2.3.1 результаты теста

| Тест                                                                   | EF5 без кэширования | EF5 кэширования | EF6 без кэширования | EF6 кэширования |
|:-----------------------------------------------------------------------|:-------------|:-----------|:-------------|:-----------|
| Перечисление всех 18723 запросов                                          | 124          | 125.4      | 124.3        | 125.3      |
| Как избежать поворота (просто сначала 800 запросов, вне зависимости от сложности)  | 41.7         | 5.5        | 40.5         | 5,4        |
| Только запросы AggregatingSubtotals (178 всего - что избавляет от поворота) | 39.5         | 4.5        | 38.1         | 4.6        |

*Все значения времени в секундах.*

Моральная - при выполнении много возможностей различных запросов (например, динамически созданные запросы), кэширование не увеличит производительность и итоговый Очистка кэша можно сохранить запросы, использующие преимущества наиболее кэширование плана из его фактическое использование.

Запросы AggregatingSubtotals являются наиболее сложных запросов, протестированных с. Как и ожидалось, тем более сложный запрос выполнен, тем больше преимуществ, вы увидите благодаря кэшированию плана запроса.

Сравнение CompiledQuery и эквивалентный запрос Entity SQL CompiledQuery именно с его кэшированный план запроса LINQ, должны быть такой же результат. На самом деле Если приложение содержит массу динамических запросов Entity SQL, заполнение кэша запросов также приведет CompiledQueries «декомпилировать», когда они удаляются из кэша. В этом случае производительность может быть повышена путем отключения кэширования на динамические запросы для определения приоритетов CompiledQueries. Еще лучше само собой, можно переписать приложение, чтобы использовать параметризованные запросы вместо динамических запросов.

### <a name="33-using-compiledquery-to-improve-performance-with-linq-queries"></a>3.3. Использование CompiledQuery для повышения производительности с помощью запросов LINQ

Наши тесты подтверждают, что с помощью CompiledQuery можно перенести преимущество 7% autocompiled запросы LINQ; Это означает, что позволяет тратить 7% меньше времени на выполнение кода из стека Entity Framework; Это означает, что ваше приложение будет 7% быстрее. Вообще говоря затраты на написание и обслуживании объектов CompiledQuery в EF 5.0 могут стоить возникли проблемы, по сравнению с преимущества. Детализация проработки может различаться, поэтому Упражнение этот параметр, если требуются дополнительные Push-уведомления в вашем проекте. Обратите внимание, что CompiledQueries только совместим с производным ObjectContext моделях и не совместим с производным DbContext моделей.

Дополнительные сведения о создании и вызове CompiledQuery см. в разделе [компилированные запросы (LINQ to Entities)](https://msdn.microsoft.com/library/bb896297.aspx).

Есть две рекомендации, которые необходимо выполнить при использовании CompiledQuery, а именно: требование использовать статические экземпляры и проблем, что они имеют с Компонуемость. Ниже следует подробное разъяснение эти две рекомендации.

#### <a name="331-use-static-compiledquery-instances"></a>3.3.1 используйте статические экземпляры CompiledQuery

Поскольку компиляции запроса LINQ занимает много времени, мы не хотим делать каждый раз, нам нужно получить данные из базы данных. Экземпляры CompiledQuery позволяют один раз скомпилировать и запустить несколько раз, но следует соблюдать осторожность и приобретение повторно использовать один и тот же экземпляр CompiledQuery каждый раз, а не его снова и снова компиляции. Использование статических членов для хранения экземпляров CompiledQuery становится необходимым; в противном случае вы не увидите каких-либо преимуществ.

Например предположим, что на странице имеется следующий текст метод для обработки, отображение продуктов выбранной категории:

``` csharp
    // Warning: this is the wrong way of using CompiledQuery
    using (NorthwindEntities context = new NorthwindEntities())
    {
        string selectedCategory = this.categoriesList.SelectedValue;

        var productsForCategory = CompiledQuery.Compile<NorthwindEntities, string, IQueryable<Product>>(
            (NorthwindEntities nwnd, string category) =>
                nwnd.Products.Where(p => p.Category.CategoryName == category)
        );

        this.productsGrid.DataSource = productsForCategory.Invoke(context, selectedCategory).ToList();
        this.productsGrid.DataBind();
    }

    this.productsGrid.Visible = true;
```

В этом случае вы создадите новый экземпляр CompiledQuery в режиме реального времени каждый раз при вызове метода. Вместо выигрыш в производительности, получая команда хранилища из кэша планов запросов, CompiledQuery будет проходить через компилятор плана каждый раз при создании нового экземпляра. На самом деле будет избавляют кэша плана запроса с помощью новой записи CompiledQuery каждый раз при вызове метода.

Вместо этого необходимо создать статический экземпляр скомпилированного запроса, чтобы каждый раз при вызове метода вызываются один и тот же скомпилированный запрос. Один из способов это, добавив экземпляр CompiledQuery в качестве члена объекта контекста.  Затем можно сделать вещей немного более чистым и читабельным доступ к CompiledQuery через вспомогательный метод:

``` csharp
    public partial class NorthwindEntities : ObjectContext
    {
        private static readonly Func<NorthwindEntities, string, IEnumerable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
            (NorthwindEntities context, string categoryName) =>
                context.Products.Where(p => p.Category.CategoryName == categoryName)
            );

        public IEnumerable<Product> GetProductsForCategory(string categoryName)
        {
            return productsForCategoryCQ.Invoke(this, categoryName).ToList();
        }
```

Этот вспомогательный метод будет вызываться следующим образом:

``` csharp
    this.productsGrid.DataSource = context.GetProductsForCategory(selectedCategory);
```

#### <a name="332-composing-over-a-compiledquery"></a>3.3.2 составление через CompiledQuery

Возможность составляемый по любой запрос LINQ является очень полезным. Чтобы сделать это, вы просто вызываете метод после IQueryable например *Skip()* или *Count()*. Тем не менее это по сути, возвращает объект IQueryable. Хотя нет ничего должно остановить вас от составления через CompiledQuery с технической точки зрения, это приведет к созданию нового объекта IQueryable, снова требуется через компилятор плана.

Некоторые компоненты будут работать с IQueryable составных объектов для включения дополнительных функций. Например, ASP. NET GridView может быть связан с данными на объект IQueryable через свойство SelectMethod. GridView будет сочетать этот объект IQueryable, чтобы разрешить сортировку и разбиение по страницам по модели данных. Как вы видите, с помощью CompiledQuery для GridView не мог попасть скомпилированный запрос, но будет создать новый запрос autocompiled.

Одно место, где вы можете столкнуться это при добавлении прогрессивного фильтры в запрос. Например предположим, что имеется страница клиентов с несколько раскрывающихся списков для необязательные фильтры (например, "Страна" и "OrdersCount"). Эти фильтры можно составляемый по результатам IQueryable из CompiledQuery. Однако это приведет к в новый запрос, который проходит через компилятор плана каждый раз при его выполнении.

``` csharp
    using (NorthwindEntities context = new NorthwindEntities())
    {
        IQueryable<Customer> myCustomers = context.InvokeCustomersForEmployee();

        if (this.orderCountFilterList.SelectedItem.Value != defaultFilterText)
        {
            int orderCount = int.Parse(orderCountFilterList.SelectedValue);
            myCustomers = myCustomers.Where(c => c.Orders.Count > orderCount);
        }

        if (this.countryFilterList.SelectedItem.Value != defaultFilterText)
        {
            myCustomers = myCustomers.Where(c => c.Address.Country == countryFilterList.SelectedValue);
        }

        this.customersGrid.DataSource = myCustomers;
        this.customersGrid.DataBind();
    }
```

 Чтобы избежать повторной компиляции, можно переписать CompiledQuery учитывать возможные фильтры:

``` csharp
    private static readonly Func<NorthwindEntities, int, int?, string, IQueryable<Customer>> customersForEmployeeWithFiltersCQ = CompiledQuery.Compile(
        (NorthwindEntities context, int empId, int? countFilter, string countryFilter) =>
            context.Customers.Where(c => c.Orders.Any(o => o.EmployeeID == empId))
            .Where(c => countFilter.HasValue == false || c.Orders.Count > countFilter)
            .Where(c => countryFilter == null || c.Address.Country == countryFilter)
        );
```

Который будет вызываться в пользовательском Интерфейсе, например:

``` csharp
    using (NorthwindEntities context = new NorthwindEntities())
    {
        int? countFilter = (this.orderCountFilterList.SelectedIndex == 0) ?
            (int?)null :
            int.Parse(this.orderCountFilterList.SelectedValue);

        string countryFilter = (this.countryFilterList.SelectedIndex == 0) ?
            null :
            this.countryFilterList.SelectedValue;

        IQueryable<Customer> myCustomers = context.InvokeCustomersForEmployeeWithFilters(
                countFilter, countryFilter);

        this.customersGrid.DataSource = myCustomers;
        this.customersGrid.DataBind();
    }
```

 Здесь компромисс — команда созданного хранилища всегда будет иметь фильтры с проверками "null", но они должны быть относительно простыми для сервера базы данных для оптимизации:

``` SQL
...
WHERE ((0 = (CASE WHEN (@p__linq__1 IS NOT NULL) THEN cast(1 as bit) WHEN (@p__linq__1 IS NULL) THEN cast(0 as bit) END)) OR ([Project3].[C2] > @p__linq__2)) AND (@p__linq__3 IS NULL OR [Project3].[Country] = @p__linq__4)
```

### <a name="34-metadata-caching"></a>3.4 кэширование метаданных

Платформа Entity Framework также поддерживает кэширование метаданных. Это по сути кэширует сведения о типе и сведения о сопоставлении типа для базы данных в разных способа подключения к той же модели. Кэш метаданных уникален в пределах одного домена приложения.

#### <a name="341-metadata-caching-algorithm"></a>3.4.1 кэширование метаданных алгоритма

1.  Сведения о метаданных для модели хранится в коллекцию ItemCollection для каждого EntityConnection.
    -   Заметим существуют разные объекты ItemCollection для разных частей модели. Например StoreItemCollections содержит сведения о модели базы данных; ObjectItemCollection содержит сведения о модели данных; EdmItemCollection содержит сведения о концептуальной модели.

2.  Если два соединения используют ту же строку подключения, они будут совместно использовать один и тот же экземпляр ItemCollection.
3.  Строки подключения функционально эквивалентны, но текстовой форме различные может привести разные метаданные кэшей. Мы помечать строки подключения, просто изменив порядок токенов следует привести общие метаданные. Однако две строки подключения, которые кажутся функционально могут не оцениваться идентичными после разметки.
4.  Коллекция ItemCollection периодически проверяется для использования. Если выяснилось, что рабочая область не обращались недавно, он будет помечена для очистки на Далее Очистка кэша.
5.  Простое создание объект EntityConnection приведет к кэшу метаданных создаваемой (хотя коллекции элементов в нем не будут инициализированы до открытия подключения). Эта рабочая область будет оставаться в памяти до кэширования алгоритм определяет, что он не «используется».

Группа консультирования клиентов написал в блоге, описывающий содержит ссылку на коллекцию ItemCollection избежание «устаревание» при использовании больших моделей: \<http://blogs.msdn.com/b/appfabriccat/archive/2010/10/22/metadataworkspace-reference-in-wcf-services.aspx>.

#### <a name="342-the-relationship-between-metadata-caching-and-query-plan-caching"></a>3.4.2 связь между кэширование метаданных и планирование кэширование запросов

Экземпляр кэша плана запроса находится в области MetadataWorkspace ItemCollection типов хранилища. Это означает, что команды кэшированном хранилище будет использоваться для запросов к каким-либо контекстом, создается с помощью заданной области MetadataWorkspace. Это также означает, что если у вас есть две строки подключения, которые немного отличаются и не соответствуют после разделения на лексемы, у вас будет другой запрос планирование экземпляров кэша.

### <a name="35-results-caching"></a>3.5 кэширование результатов

Вместе с результатами кэширование (также называется «второго уровня кэширование») и сохранять результаты запросов в локальном кэше. При выполнении запроса, вы увидите результаты доступны локально, прежде чем запрос к хранилищу. Хотя кэширование результатов не поддерживаются Entity Framework, это можно добавить кэша второго уровня с помощью поставщика упаковки. Поставщик упаковки примере с помощью кэша второго уровня — в Alachisoft [зависимости кэша второго уровня Entity Framework от NCache](http://www.alachisoft.com/ncache/entity-framework.html).

Эта реализация кэширования второго уровня является внедренного функциональные возможности, которая принимает место после оценки выражения LINQ (и funcletized) и вычисляется или получить из кэша первого уровня плана выполнения запроса. Кэша второго уровня будут храниться только необработанных результатов, поэтому конвейер материализации по-прежнему выполняется позже.

#### <a name="351-additional-references-for-results-caching-with-the-wrapping-provider"></a>3.5.1 Дополнительные ссылки для результатов, кэширование с поставщиком упаковки

-   Джули Лерман написал статьи MSDN «Второго уровня кэширования в Entity Framework и Windows Azure», которая включает в себя обновление упаковки в образец поставщика, для использования кэширования Windows Server AppFabric: [https://msdn.microsoft.com/magazine/hh394143.aspx](https://msdn.microsoft.com/magazine/hh394143.aspx)
-   Если вы работаете с Entity Framework 5, в блоге группы разработчиков имеет post, в котором описано, как восстановить нормальную с поставщиком кэширования для Entity Framework 5: \<http://blogs.msdn.com/b/adonet/archive/2010/09/13/ef-caching-with-jarek-kowalski-s-provider.aspx>. Она также включает шаблон T4 для автоматизации, добавление второго уровня кэширования в проект.

## <a name="4-autocompiled-queries"></a>4 Autocompiled запросов

Во время запроса к базе данных с помощью Entity Framework, то он должен проходить через ряд шагов до фактически материализации результатов; один шаг — компиляции запроса. Известно, что запросы Entity SQL иметь хорошую производительность, как они автоматически сохраняются в кэше, что второй или третий раз выполнять тот же запрос, его можно пропустить компилятора плана и вместо этого использовать кэшированный план.

Entity Framework 5 появился автоматическое кэширование для LINQ для запросов сущностей. В прошлых выпусках платформы Entity Framework, создание CompiledQuery для ускорения производительность была обычной практикой, так как это делает LINQ to Entities в запрос может быть кэширован. Так как кэширование теперь выполняется автоматически без использования CompiledQuery, мы называем эту функцию «autocompiled запросы». Дополнительные сведения о кэше планов запросов и его механизмы см. в разделе Кэширование планов запросов.

Платформа Entity Framework обнаруживает, когда запрос требует повторной компиляции, и делает это, при вызове даже если компилировали до запроса. Ниже приведены распространенные условия, вызывающие повторную компиляцию запроса.

-   Изменение MergeOption, связанный в запрос. Кэшированный запрос не будет использоваться, вместо этого компилятор план будет выполняться снова и кэшируемый только что созданный план.
-   Изменение значения ContextOptions.UseCSharpNullComparisonBehavior. Вы получаете тот же эффект, что изменение MergeOption.

Другие условия можно запретить запроса из кэша. Ниже приведены распространенные примеры.

-   С помощью IEnumerable&lt;T&gt;. Содержит&lt;&gt;(значение T).
-   Использование функций, которые создают запросы с константами.
-   С помощью свойств объекта не сопоставлен.
-   Связывание запроса в другой запрос, который требует повторной компиляции.

### <a name="41-using-ienumerablelttgtcontainslttgtt-value"></a>4.1 с помощью IEnumerable&lt;T&gt;. Содержит&lt;T&gt;(значение T)

Платформа Entity Framework не кэширует запросы, которые вызывают IEnumerable&lt;T&gt;. Содержит&lt;T&gt;(значение T) по коллекции в памяти, так как значения коллекции считаются временными. В следующем примере запроса не будут кэшироваться, поэтому он всегда будет обрабатываться компилятором плана:

``` csharp
int[] ids = new int[10000];
...
using (var context = new MyContext())
{
    var query = context.MyEntities
                    .Where(entity => ids.Contains(entity.Id));

    var results = query.ToList();
    ...
}
```

Обратите внимание, что выполняемого размер IEnumerable от содержащий определяет, насколько быстро или медленно как запрос компилируется. Может наблюдаться снижение производительности значительно при использовании больших коллекций, как показано в приведенном выше примере.

Оптимизировано Entity Framework 6 как IEnumerable&lt;T&gt;. Содержит&lt;T&gt;(значение T) работает при выполнении запросов. Код SQL, который создается во много раз быстрее создавать и более удобном для чтения, и в большинстве случаев также выполняется быстрее на сервере.

### <a name="42-using-functions-that-produce-queries-with-constants"></a>4.2 с помощью функций, которые создают запросы с константами

Операторы Skip(), методы Take(), Contains() и DefautIfEmpty() LINQ не вызывают SQL-запросы с параметрами, но вместо этого поместите значения, передаваемые им как константы. По этой причине запросы, которые в противном случае могут быть идентичными окажутся избавляют запрос Планируйте кэша, как в стеке EF, так и на сервере базы данных и не получить reutilized, если же константы не используются при выполнении последующих запросов. Пример:

``` csharp
var id = 10;
...
using (var context = new MyContext())
{
    var query = context.MyEntities.Select(entity => entity.Id).Contains(id);

    var results = query.ToList();
    ...
}
```

В этом примере каждый раз при выполнении этого запроса с другим значением для идентификатора запроса будут скомпилированы в новый план.

В определенной следует обратить внимание на использование предложения Skip и Take при выполнении разбиения по страницам. В EF6 этих методов есть перегрузки, лямбда-выражения, который фактически делает кэшированного плана запроса для повторного использования, так как EF можно фиксировать переменные, передаваемый для этих методов и преобразовывать их в параметров SQLparameters. Это также помогает сохранять кэш чище, поскольку в противном случае каждый запрос с различные константы для предложения Skip и Take бы получает собственную запись кэша плана запроса.

Рассмотрим следующий код, который не является оптимальным, но предназначен только для того чтобы проиллюстрировать этот класс запросов:

``` csharp
var customers = context.Customers.OrderBy(c => c.LastName);
for (var i = 0; i < count; ++i)
{
    var currentCustomer = customers.Skip(i).FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

Более быстрой версии этого кода будет включать в себя вызов Skip с лямбда-выражения:

``` csharp
var customers = context.Customers.OrderBy(c => c.LastName);
for (var i = 0; i < count; ++i)
{
    var currentCustomer = customers.Skip(() => i).FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

Второй фрагмент могут выполняться до 11% быстрее, потому что каждый раз выполняется запрос, сохраняющий время ЦП и позволяет избежать избавляют кэша запросов, используется один и тот же план запроса. Кроме того так как параметр Skip, в замыкании код может также выглядеть теперь:

``` csharp
var i = 0;
var skippyCustomers = context.Customers.OrderBy(c => c.LastName).Skip(() => i);
for (; i < count; ++i)
{
    var currentCustomer = skippyCustomers.FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

### <a name="43-using-the-properties-of-a-non-mapped-object"></a>4.3 с помощью свойств объекта несопоставленные

Когда запрос использует свойства типа несопоставленные объекта как параметр, а затем запрос не будет помещаться. Пример:

``` csharp
using (var context = new MyContext())
{
    var myObject = new NonMappedType();

    var query = from entity in context.MyEntities
                where entity.Name.StartsWith(myObject.MyProperty)
                select entity;

   var results = query.ToList();
    ...
}
```

В этом примере предполагается, что класс NonMappedType не является частью модели сущности. Этот запрос можно легко изменить, не используйте тип несопоставленные и вместо этого использовать локальную переменную в качестве параметра к запросу:

``` csharp
using (var context = new MyContext())
{
    var myObject = new NonMappedType();
    var myValue = myObject.MyProperty;
    var query = from entity in context.MyEntities
                where entity.Name.StartsWith(myValue)
                select entity;

    var results = query.ToList();
    ...
}
```

В этом случае запрос будет помещаться и выиграет от кэша планов запросов.

### <a name="44-linking-to-queries-that-require-recompiling"></a>4.4 связывание запросов, которые требует повторной компиляции

Следующие тот же пример, как описано выше при наличии второй запрос, который основывается на запросе, который нужно перекомпилировать, весь второй запрос будет также перекомпилирован. Ниже приведен пример, чтобы продемонстрировать этот сценарий:

``` csharp
int[] ids = new int[10000];
...
using (var context = new MyContext())
{
    var firstQuery = from entity in context.MyEntities
                        where ids.Contains(entity.Id)
                        select entity;

    var secondQuery = from entity in context.MyEntities
                        where firstQuery.Any(otherEntity => otherEntity.Id == entity.Id)
                        select entity;

    var results = secondQuery.ToList();
    ...
}
```

Пример является универсальным, но он иллюстрирует, как связывание с firstQuery вызывает secondQuery смогут окажутся кэшированными. Если firstQuery не был запрос, который требует повторной компиляции, затем secondQuery бы были кэшированы.

## <a name="5-notracking-queries"></a>5 NoTracking запросов

### <a name="51-disabling-change-tracking-to-reduce-state-management-overhead"></a>5.1 отключить отслеживание изменений, чтобы сократить расходы на управление состоянием

Если вы являетесь в сценарии только для чтения и хотите избежать дополнительной нагрузки при загрузке объектов в диспетчере ObjectStateManager, можно выполнять запросы «No отслеживания».  Отслеживание изменений можно отключить на уровне запроса.

Обратите внимание, что путем отключения отслеживания изменений равносильно отключению этого кэша объектов. При запросе сущности, мы не может пропустить материализации, используя результаты запроса материализуются ранее из ObjectStateManager. При запросе несколько раз для те же сущности, на том же контексте, может увидеть извлечь выгоду от включения отслеживания изменений производительности.

При запросе с помощью ObjectContext, экземпляры ObjectQuery и ObjectSet запомнит MergeOption после того как оно задано, и запросы, которые составляются на них будет наследовать действующие MergeOption родительского запроса. При использовании DbContext, отслеживания можно отключить, вызвав модификатор AsNoTracking() на DbSet.

#### <a name="511-disabling-change-tracking-for-a-query-when-using-dbcontext"></a>5.1.1 Отключение отслеживания изменений для запроса при использовании DbContext

Можно переключить режим запроса для NoTracking с помощью цепочки из вызова метода AsNoTracking() в запросе. В отличие от ObjectQuery DbSet и DbQuery классы в DbContext API не имеют изменяемые свойства для MergeOption.

``` csharp
    var productsForCategory = from p in context.Products.AsNoTracking()
                                where p.Category.CategoryName == selectedCategory
                                select p;


```

#### <a name="512-disabling-change-tracking-at-the-query-level-using-objectcontext"></a>5.1.2 Отключение отслеживания на уровне запроса с помощью ObjectContext изменений

``` csharp
    var productsForCategory = from p in context.Products
                                where p.Category.CategoryName == selectedCategory
                                select p;

    ((ObjectQuery)productsForCategory).MergeOption = MergeOption.NoTracking;
```

#### <a name="513-disabling-change-tracking-for-an-entire-entity-set-using-objectcontext"></a>5.1.3 Отключение отслеживания изменений для всего набора с помощью ObjectContext сущностей

``` csharp
    context.Products.MergeOption = MergeOption.NoTracking;

    var productsForCategory = from p in context.Products
                                where p.Category.CategoryName == selectedCategory
                                select p;
```

### <a name="52test-metrics-demonstrating-the-performance-benefit-of-notracking-queries"></a>5.2 показатели, демонстрирующие преимущества высокой производительности запросов NoTracking теста

В этом тесте мы будем за счет заполнения, сравнивая отслеживания к запросам NoTracking для модели Navision ObjectStateManager. См. в приложении описание модели Navision и типы запросов, которые были выполнены. В этом тесте мы итерацию по списку запросов и выполнения каждого из них один раз. Мы запустили две вариации теста, один раз с NoTracking запросов и один раз с параметром слияния по умолчанию «AppendOnly». Мы выполнили налагаются три раза и взять среднее значение выполнения. Между двумя тестами Очистка кэша запросов на SQL Server и сжатие базы данных tempdb, выполнив следующие команды:

1.  DBCC DROPCLEANBUFFERS
2.  DBCC FREEPROCCACHE
3.  DBCC SHRINKDATABASE (tempdb, 0)

Результаты тестов, медианы более чем трех запуски:

|                        | ОТСЛЕЖИВАНИЕ — РАБОЧИЙ НАБОР | НЕТ — ВРЕМЯ | ИНКРЕМЕНТИРУЕМЫЕ — РАБОЧИЙ НАБОР | ДОБАВЛЕНИЕ ТОЛЬКО — ВРЕМЯ |
|:-----------------------|:--------------------------|:-------------------|:--------------------------|:-------------------|
| **Entity Framework 5** | 460361728                 | 1163536 ms         | 596545536                 | 1273042 ms         |
| **Entity Framework 6** | 647127040                 | 190228 ms          | 832798720                 | 195521 ms          |

Entity Framework 5 будет иметь небольшого объема памяти в конце выполнения, чем Entity Framework 6. Дополнительная память, занятая Entity Framework 6 является результатом дополнительную память структуры и кода, включение новых функций и повышения производительности.

Имеется также различия в объем памяти при использовании ObjectStateManager. Entity Framework 5 увеличить ее объем, 30%, когда отслеживает все сущности, которые мы материализованных из базы данных. Entity Framework 6 увеличить ее объем, 28%, при этом.

С точки зрения времени Entity Framework 6 превосходит по производительности Entity Framework 5 в этом тесте, большие поля. Entity Framework 6 выполнить тест в примерно 16% время, затраченное Entity Framework 5. Кроме того Entity Framework 5 занимает 9% больше времени при использовании ObjectStateManager. В отличие от этого Entity Framework 6 используется 3% больше времени, при использовании ObjectStateManager.

## <a name="6-query-execution-options"></a>6 параметры выполнения запроса

Платформа Entity Framework предлагает несколько разных способов для запроса. Мы рассмотрим следующие параметры, сравнить преимущества и недостатки каждого из них и проверить соответствующие характеристики производительности:

-   LINQ to Entities.
-   Нет отслеживания LINQ to Entities.
-   Язык Entity SQL через ObjectQuery.
-   Язык Entity SQL через EntityCommand.
-   ExecuteStoreQuery.
-   SQL-запрос.
-   CompiledQuery.

### <a name="61-linq-to-entities-queries"></a>6.1 запросы LINQ to Entities

``` csharp
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
```

**Преимущества**

-   Подходит для операций CUD.
-   Полностью материализованные объекты.
-   Самый простой для записи с синтаксисом, встроенные в язык программирования.
-   Хорошую производительность.

**Недостатки**

-   Некоторые технические ограничения, такие как:
    -   Шаблоны, использование DefaultIfEmpty для запросов, OUTER JOIN привести к более сложные запросы, чем простые инструкции OUTER JOIN в Entity SQL.
    -   Вы по-прежнему не удается использовать ПОДОБНЫЕ с совпадающими общий шаблон.

### <a name="62-no-tracking-linq-to-entities-queries"></a>6.2 не отслеживания LINQ для запросов сущностей

Когда контекст наследуется ObjectContext:

``` csharp
context.Products.MergeOption = MergeOption.NoTracking;
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
```

Когда контекст наследуется DbContext:

``` csharp
var q = context.Products.AsNoTracking()
                        .Where(p => p.Category.CategoryName == "Beverages");
```

**Преимущества**

-   Повышенная производительность по сравнению обычных запросов LINQ.
-   Полностью материализованные объекты.
-   Самый простой для записи с синтаксисом, встроенные в язык программирования.

**Недостатки**

-   Не подходит для операций CUD.
-   Некоторые технические ограничения, такие как:
    -   Шаблоны, использование DefaultIfEmpty для запросов, OUTER JOIN привести к более сложные запросы, чем простые инструкции OUTER JOIN в Entity SQL.
    -   Вы по-прежнему не удается использовать ПОДОБНЫЕ с совпадающими общий шаблон.

Обратите внимание на то, что запросы, скалярные свойства проекта не отслеживаются даже если NoTracking не указан. Пример:

``` csharp
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages").Select(p => new { p.ProductName });
```

Этот запрос не указывает явно, NoTracking, но так как он не материализации тип, известно, что диспетчер состояния объекта затем материализованный результат не отслеживается.

### <a name="63-entity-sql-over-an-objectquery"></a>6.3 entity SQL через ObjectQuery

``` csharp
ObjectQuery<Product> products = context.Products.Where("it.Category.CategoryName = 'Beverages'");
```

**Преимущества**

-   Подходит для операций CUD.
-   Полностью материализованные объекты.
-   Поддерживает кэширование плана запросов.

**Недостатки**

-   Включает в себя строки текстовых запросов, которые являются более могут совершать ошибки чем конструкции запросов, встроенные в язык.

### <a name="64-entity-sql-over-an-entity-command"></a>6.4 entity SQL через команду сущности

``` csharp
EntityCommand cmd = eConn.CreateCommand();
cmd.CommandText = "Select p From NorthwindEntities.Products As p Where p.Category.CategoryName = 'Beverages'";

using (EntityDataReader reader = cmd.ExecuteReader(CommandBehavior.SequentialAccess))
{
    while (reader.Read())
    {
        // manually 'materialize' the product
    }
}
```

**Преимущества**

-   Кэширование плана в .NET 4.0 (кэширование плана поддерживается всеми типами запросов в .NET 4.5) запросов поддерживает.

**Недостатки**

-   Включает в себя строки текстовых запросов, которые являются более могут совершать ошибки чем конструкции запросов, встроенные в язык.
-   Не подходит для операций CUD.
-   Результаты материализуются автоматически и должны быть считаны из считывателя данных.

### <a name="65-sqlquery-and-executestorequery"></a>6.5 SqlQuery и ExecuteStoreQuery

SQL-запрос в базе данных:

``` csharp
// use this to obtain entities and not track them
var q1 = context.Database.SqlQuery<Product>("select * from products");
```

SQL-запрос на DbSet:

``` csharp
// use this to obtain entities and have them tracked
var q2 = context.Products.SqlQuery("select * from products");
```

ExecyteStoreQuery:

``` csharp
var beverages = context.ExecuteStoreQuery<Product>(
@"     SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued, P.DiscontinuedDate
       FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
       WHERE        (C.CategoryName = 'Beverages')"
);
```

**Преимущества**

-   Обычно высокая производительность, так как план компилятора пропускается.
-   Полностью материализованные объекты.
-   Подходит для операций CUD при использовании из DbSet.

**Недостатки**

-   Запрос является текстовым и подвержено ошибкам.
-   Запрос привязывается к конкретной серверной части с использованием семантики хранилища вместо концептуальная семантика.
-   При наличии наследования собственноручно запрос должен учитывать условия сопоставления для запрошенного типа.

### <a name="66-compiledquery"></a>6.6 CompiledQuery

``` csharp
private static readonly Func<NorthwindEntities, string, IQueryable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
    (NorthwindEntities context, string categoryName) =>
        context.Products.Where(p => p.Category.CategoryName == categoryName)
        );
…
var q = context.InvokeProductsForCategoryCQ("Beverages");
```

**Преимущества**

-   Доступно до 7% производительность через обычные запросы LINQ.
-   Полностью материализованные объекты.
-   Подходит для операций CUD.

**Недостатки**

-   Увеличить сложность и издержки программирования.
-   Улучшение производительности теряется при составлении поверх скомпилированный запрос.
-   Нельзя записать некоторые запросы LINQ в качестве CompiledQuery - например, проекции, анонимных типов.

### <a name="67-performance-comparison-of-different-query-options"></a>6.7 Сравнение производительности параметров различных запросов

Простой микротестами, где создания контекста не истек, были помещены в тест. Мы разработали, запрашивая 5000 раз набор сущностей без кэширования в контролируемой среде. Эти числа должны браться с предупреждением: они не отражают фактические значения, созданные приложением, но они являются очень точные измерения уровня использования разница в производительности при сравнении разных составления запросов яблоки требуют, за исключением затрат на создание нового контекста.

| EF  | Тест                                 | Время (мс) | Память   |
|:----|:-------------------------------------|:----------|:---------|
| EF5 | ObjectContext ESQL                   | 2414      | 38801408 |
| EF5 | Запрос Linq ObjectContext             | 2692      | 38277120 |
| EF5 | DbContext Linq-запроса без отслеживания     | 2818      | 41840640 |
| EF5 | Запрос Linq DbContext                 | 2930      | 41771008 |
| EF5 | ObjectContext Linq-запроса без отслеживания | 3013      | 38412288 |
|     |                                      |           |          |
| EF6 | ObjectContext ESQL                   | 2059      | 46039040 |
| EF6 | Запрос Linq ObjectContext             | 3074      | 45248512 |
| EF6 | DbContext Linq-запроса без отслеживания     | 3125      | 47575040 |
| EF6 | Запрос Linq DbContext                 | 3420      | 47652864 |
| EF6 | ObjectContext Linq-запроса без отслеживания | 3593      | 45260800 |

![Micro EF5 тесты производительности, 5000 итераций "горячего" резервирования](~/ef6/media/ef5micro5000warm.png)

![Тесты производительности micro EF6, 5000 итераций "горячего" резервирования](~/ef6/media/ef6micro5000warm.png)

Микротестами очень чувствительны к небольшие изменения в коде. В этом случае разница между стоимость Entity Framework 5 и Entity Framework 6 возникают из-за появлением [перехвата](~/ef6/fundamentals/logging-and-interception.md) и [транзакций улучшения](~/ef6/saving/transactions.md). Однако эти числа микротестами являются смещаться представления к платформе Entity Framework достигается очень небольшой фрагмент. Сценарии из реальной жизни "горячего" резервирования запросов должны отсутствовать снижение производительности при обновлении с Entity Framework 5 для Entity Framework 6.

Чтобы сравнить производительность реальных параметры другой запрос, мы создали 5 отдельный тестовый вариации, где используется параметр другой запрос для выбора всех продуктов, которого зовут категории «Напитки». Каждая итерация включает затрат на создание контекста и стоимость материализации все возвращаемые сущности. Перед созданием суммы истекло время ожидания 1000 итераций, выполняются untimed 10 итераций. Показаны не все результаты выполнения медианы, взятое из 5 запусков каждого теста. Дополнительные сведения см. приложение Б, которая включает код для теста.

| EF  | Тест                                        | Время (мс) | Память   |
|:----|:--------------------------------------------|:----------|:---------|
| EF5 | Команда ObjectContext сущности                | 621       | 39350272 |
| EF5 | DbContext Sql-запроса для базы данных             | 825       | 37519360 |
| EF5 | Query Store ObjectContext                   | 878       | 39460864 |
| EF5 | ObjectContext Linq-запроса без отслеживания        | 969       | 38293504 |
| EF5 | ObjectContext Entity Sql с помощью запроса объектов | 1089      | 38981632 |
| EF5 | Скомпилированный запрос ObjectContext                | 1099      | 38682624 |
| EF5 | Запрос Linq ObjectContext                    | 1152      | 38178816 |
| EF5 | DbContext Linq-запроса без отслеживания            | 1208      | 41803776 |
| EF5 | DbContext Sql-запроса для DbSet                | 1414      | 37982208 |
| EF5 | Запрос Linq DbContext                        | 1574      | 41738240 |
|     |                                             |           |          |
| EF6 | Команда ObjectContext сущности                | 480       | 47247360 |
| EF6 | Query Store ObjectContext                   | 493       | 46739456 |
| EF6 | DbContext Sql-запроса для базы данных             | 614       | 41607168 |
| EF6 | ObjectContext Linq-запроса без отслеживания        | 684       | 46333952 |
| EF6 | ObjectContext Entity Sql с помощью запроса объектов | 767       | 48865280 |
| EF6 | Скомпилированный запрос ObjectContext                | 788       | 48467968 |
| EF6 | DbContext Linq-запроса без отслеживания            | 878       | 47554560 |
| EF6 | Запрос Linq ObjectContext                    | 953       | 47632384 |
| EF6 | DbContext Sql-запроса для DbSet                | 1023      | 41992192 |
| EF6 | Запрос Linq DbContext                        | 1290      | 47529984 |


![EF5 «теплого» запроса 1000 итераций](~/ef6/media/ef5warmquery1000.png)

![EF6 «теплого» запроса 1000 итераций](~/ef6/media/ef6warmquery1000.png)

> [!NOTE]
> Для полноты информации мы включили как вариант, где мы выполнить запрос Entity SQL в EntityCommand. Тем не менее, так как результаты материализуются для таких запросов, сравнение не обязательно яблоки требуют. Тест включает приближенное к материализации также попытаться создать при более равноправном сравнения.

В данном случае end-to-end, Entity Framework 6 превосходит по производительности Entity Framework 5 из-за повышение производительности на несколько частей стека, в том числе гораздо скромнее инициализации DbContext и быстрее MetadataCollection&lt;T&gt; уточняющих запросов.

## <a name="7-design-time-performance-considerations"></a>7 вопросы производительности разработки

### <a name="71-inheritance-strategies"></a>7.1 стратегии наследования

Еще один нюанс производительности при использовании Entity Framework является использовании стратегии наследования. Платформа Entity Framework поддерживает три основных типа наследования и их комбинации:

-   Таблица на иерархию (TPH) — устанавливаемый карты в таблицу со столбцом дискриминатора, чтобы указать, какой конкретный тип в иерархии наследования каждого представляется в строке.
-   Таблица на тип (TPT) — где каждый тип имеет собственную таблицу в базе данных; дочерние таблицы только определить столбцы, которые не содержат родительской таблицы.
-   Таблицы на класс (TPC) — где каждый тип имеет собственную полную таблицу в базе данных; дочерние таблицы определите всех их полях, включая определенные в родительских типов.

Если модель использует наследование TPT, запросы, которые создаются будет сложнее, чем те, которые были созданы с помощью наследования стратегиях, которые могут на более длительное время выполнения в хранилище.  Обычно займет больше времени для формирования запросов на основе модели TPT и для материализации полученные объекты.

См. в разделе «Сведения о производительности при использовании наследования TPT (одна таблица на тип) на платформе Entity Framework» в блоге MSDN: \<http://blogs.msdn.com/b/adonet/archive/2010/08/17/performance-considerations-when-using-tpt-table-per-type-inheritance-in-the-entity-framework.aspx>.

#### <a name="711-avoiding-tpt-in-model-first-or-code-first-applications"></a>7.1.1 Предотвращение TPT в приложениях сначала модель» или «сначала код

При создании модели поверх существующей базы данных со схемой, TPT, у вас нет множество параметров. Но при создании приложения с помощью Model First или Code First, следует избегать наследования TPT для проблем с производительностью.

При использовании Model First в мастере конструктора сущностей, вы получите TPT для любой наследования в модели. Переключиться на стратегию наследование TPH с Model First следует можно использовать «сущности конструктор базы данных поколения Power Pack» доступны из коллекции Visual Studio ( \<http://visualstudiogallery.msdn.microsoft.com/df3541c3-d833-4b65-b942-989e7ec74c87/>).

При использовании Code First для настройки сопоставления модели с наследованием, по умолчанию EF будет использовать TPH, поэтому все сущности в иерархии наследования сопоставляется с той же таблицы. См. в разделе «Сопоставление с Fluent API» в статье «Код первой в сущности Framework4.1» в журнале MSDN Magazine ( [http://msdn.microsoft.com/magazine/hh126815.aspx](https://msdn.microsoft.com/magazine/hh126815.aspx)) для получения дополнительных сведений.

### <a name="72-upgrading-from-ef4-to-improve-model-generation-time"></a>7.2 обновляете EF4 для улучшения формирования модели времени

Это улучшение связанные с SQL Server для алгоритма, который создает уровень хранилища (SSDL) модели доступен в Entity Framework 5 и 6, а также как обновление для Entity Framework 4 при установке Visual Studio 2010 с пакетом обновления 1. Ниже приведены результаты теста демонстрируют улучшения при генерации очень большие модели, в этом случае Navision модели. Дополнительные сведения о ней см.

Модель содержит наборы сущностей 1005 и 4227 наборы ассоциаций.

| Параметр Configuration                              | Декомпозиция затраченное время                                                                                                                                               |
|:-------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Visual Studio 2010, платформа Entity Framework 4     | Создание языка SSDL: 2 часа 27 мин. <br/> Создание сопоставления: 1 секунда <br/> Создание языка CSDL: 1 секунда <br/> Создание ObjectLayer: 1 секунда <br/> Создание представлений: 2 мин 14 h. |
| Visual Studio 2010 с пакетом обновления 1, Entity Framework 4 | Создание языка SSDL: 1 секунда <br/> Создание сопоставления: 1 секунда <br/> Создание языка CSDL: 1 секунда <br/> Создание ObjectLayer: 1 секунда <br/> Создание представлений: 1 час 53 мин.   |
| Visual Studio 2013, Entity Framework 5     | Создание языка SSDL: 1 секунда <br/> Создание сопоставления: 1 секунда <br/> Создание языка CSDL: 1 секунда <br/> Создание ObjectLayer: 1 секунда <br/> Создание представлений: 65 минут    |
| Visual Studio 2013, Entity Framework 6     | Создание языка SSDL: 1 секунда <br/> Создание сопоставления: 1 секунда <br/> Создание языка CSDL: 1 секунда <br/> Создание ObjectLayer: 1 секунда <br/> Создание представлений: 28 секунд.   |


Стоит отметить, что при создании на языке SSDL, нагрузки почти полностью расходуется на SQL Server, пока клиентский компьютер для разработки находится в состоянии ожидания простоя, результаты могут возвращаться с сервера. Администраторы баз данных особенно следует оценить это улучшение. Стоит также отметить, что по сути всего затраты на создание модели происходит в средств создания представления теперь.

### <a name="73-splitting-large-models-with-database-first-and-model-first"></a>7.3 разделение большие модели с базой данных, сначала и Model First

По мере увеличения размера модели рабочей области конструктора становится загроможденным и сложно использовать. Обычно мы рассмотрим модель с более чем 300 сущностями слишком большой для эффективного использования конструктора. В следующей записи блога описывается несколько вариантов для разделения больших моделей: \<http://blogs.msdn.com/b/adonet/archive/2008/11/25/working-with-large-models-in-entity-framework-part-2.aspx>.

Post был написан для первой версии Entity Framework, но по-прежнему применяются действия.

### <a name="74-performance-considerations-with-the-entity-data-source-control"></a>7.4 вопросы производительности с элементом управления источником данных сущности

Мы видели вариантов в многопоточных производительности и нагрузочные тесты, где значительно снижается производительность веб-приложение, использующее элемент управления EntityDataSource. Причиной является то, что EntityDataSource многократно вызывает MetadataWorkspace.LoadFromAssembly для сборок, указанных для веб-приложения для обнаружения типов для использования в качестве сущностей.

Решение — присвоить ContextTypeName элемента управления EntityDataSource имя типа производного класса ObjectContext. Это отключает механизм, который сканирует все связанные сборки для типов сущностей.

Установив в поле ContextTypeName также предотвращает функциональной проблемы, где EntityDataSource в .NET 4.0 выдает исключения ReflectionTypeLoadException при его не удается загрузить тип из сборки с помощью отражения. Эта проблема была устранена в .NET 4.5.

### <a name="75-poco-entities-and-change-tracking-proxies"></a>7.5 сущностей POCO и прокси, отслеживающих изменения

Платформа Entity Framework позволяет использовать пользовательские классы данных с моделью данных без внесения изменений в классах данных. Это означает, что с моделью данных могут быть использованы традиционные объекты среды CLR (POCO), например существующие объекты домена. Классы данных POCO (также известный как игнорирующих сохраняемость объектов), которые сопоставлены с сущностями, которые определены в модели данных, поддерживают большинство того же запроса, вставки, обновления и удаления, что и типы сущностей, создаваемых средствами модели EDM.

Платформа Entity Framework можно также создать прокси-классы, производные от типов POCO, которые используются для включения функций, таких как отложенная загрузка и автоматическое отслеживание изменений для сущностей POCO. Классы POCO должны соответствовать определенным требованиям, чтобы разрешить Entity Framework для использования прокси-серверы, как описано здесь: [http://msdn.microsoft.com/library/dd468057.aspx](https://msdn.microsoft.com/library/dd468057.aspx).

Возможность отслеживания учетных записей-посредников уведомит диспетчер состояния объекта каждый раз, в каких-либо свойств сущностей имеет свое значение, поэтому платформа Entity Framework знает фактическое состояние сущностей постоянно. Это делается путем добавления события уведомления в тело методов задания свойств и необходимости обработки таких событий диспетчера состояния объектов. Обратите внимание, что создание учетной записи-посредника сущности обычно будет быть дороже, чем создание сущности POCO без прокси-сервера из-за добавлен набор события, созданные с Entity Framework.

Когда нет прокси отслеживания изменений для сущности POCO, изменения можно найти, сравнением содержимого строк в одной сущности для копии предыдущее сохраненное состояние. Это сравнение глубокого станет длительное время при наличии нескольких сущностей в контексте, или когда сущностей имеют очень большой объем свойства, даже если ни одна из них изменен с момента последнего сравнения.

В сводке: вам нужно оплатить производительность при создании прокси отслеживания изменений, но отслеживания изменений поможет вам ускорить процесс обнаружения изменений, когда сущностей имеют много свойств, или при наличии нескольких сущностей в модели. Для сущностей с небольшим числом свойств, где объем сущностей не увеличиваться слишком много наличие прокси отслеживания изменений может оказаться много преимуществ.

## <a name="8-loading-related-entities"></a>8 загрузка связанных сущностей

### <a name="81-lazy-loading-vs-eager-loading"></a>8.1 vs отложенной загрузки. Активная загрузка

Платформа Entity Framework предлагает несколько способов загрузки сущностей, связанных с вашей целевой сущности. Например, при запросе для продуктов, можно разными способами загружаются связанные заказы в диспетчер состояния объекта. С точки зрения производительности будет крупнейших вопрос загрузки связанных сущностей, необходимость использования отложенной загрузки или Безотложная загрузка.

Если вы используете, упреждающая загрузка, связанные сущности загружаются вместе с вашей целевой набор сущностей. При использовании инструкции Include в запросе, чтобы указать, какие связанные сущности, которые вы хотите перенести.

При использовании отложенной загрузки, начальный запрос вернет только в целевой набор сущностей. Но при каждом обращении к свойству навигации, другой запрос, получающий хранилище, чтобы загрузить связанные сущности.

После загрузки сущности, любые дальнейшие запросы для сущности будет загружать непосредственно из диспетчера состояний объекта, при использовании отложенной загрузки или Безотложная загрузка.

### <a name="82-how-to-choose-between-lazy-loading-and-eager-loading"></a>8.2 о выборе между отложенной загрузки и упреждающая загрузка

Важно понимать разницу между отложенной загрузки и упреждающая загрузка, таким образом, чтобы сделать правильный выбор для вашего приложения. Это поможет вам оценить компромисс между нескольких запросов в базе данных и один запрос, который может содержать большой объем данных. Возможно, следует использовать безотложную загрузку в некоторые части приложения и отложенной загрузки в других частях.

Пример того, что происходит за кулисами Предположим, что вам нужно создать запрос для клиентов, проживающих в Великобритании и их число заказов.

**Используя Безотложную загрузку**

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var ukCustomers = context.Customers.Include(c => c.Orders).Where(c => c.Address.Country == "UK");
    var chosenCustomer = AskUserToPickCustomer(ukCustomers);
    Console.WriteLine("Customer Id: {0} has {1} orders", customer.CustomerID, customer.Orders.Count);
}
```

**Использование отложенной загрузки**

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    context.ContextOptions.LazyLoadingEnabled = true;

    //Notice that the Include method call is missing in the query
    var ukCustomers = context.Customers.Where(c => c.Address.Country == "UK");

    var chosenCustomer = AskUserToPickCustomer(ukCustomers);
    Console.WriteLine("Customer Id: {0} has {1} orders", customer.CustomerID, customer.Orders.Count);
}
```

При использовании Безотложная загрузка, будет выдавать запрос, возвращает всех заказчиков и все заказы. Команда хранилища выглядит как:

``` SQL
SELECT
[Project1].[C1] AS [C1],
[Project1].[CustomerID] AS [CustomerID],
[Project1].[CompanyName] AS [CompanyName],
[Project1].[ContactName] AS [ContactName],
[Project1].[ContactTitle] AS [ContactTitle],
[Project1].[Address] AS [Address],
[Project1].[City] AS [City],
[Project1].[Region] AS [Region],
[Project1].[PostalCode] AS [PostalCode],
[Project1].[Country] AS [Country],
[Project1].[Phone] AS [Phone],
[Project1].[Fax] AS [Fax],
[Project1].[C2] AS [C2],
[Project1].[OrderID] AS [OrderID],
[Project1].[CustomerID1] AS [CustomerID1],
[Project1].[EmployeeID] AS [EmployeeID],
[Project1].[OrderDate] AS [OrderDate],
[Project1].[RequiredDate] AS [RequiredDate],
[Project1].[ShippedDate] AS [ShippedDate],
[Project1].[ShipVia] AS [ShipVia],
[Project1].[Freight] AS [Freight],
[Project1].[ShipName] AS [ShipName],
[Project1].[ShipAddress] AS [ShipAddress],
[Project1].[ShipCity] AS [ShipCity],
[Project1].[ShipRegion] AS [ShipRegion],
[Project1].[ShipPostalCode] AS [ShipPostalCode],
[Project1].[ShipCountry] AS [ShipCountry]
FROM ( SELECT
      [Extent1].[CustomerID] AS [CustomerID],
       [Extent1].[CompanyName] AS [CompanyName],
       [Extent1].[ContactName] AS [ContactName],
       [Extent1].[ContactTitle] AS [ContactTitle],
       [Extent1].[Address] AS [Address],
       [Extent1].[City] AS [City],
       [Extent1].[Region] AS [Region],
       [Extent1].[PostalCode] AS [PostalCode],
       [Extent1].[Country] AS [Country],
       [Extent1].[Phone] AS [Phone],
       [Extent1].[Fax] AS [Fax],
      1 AS [C1],
       [Extent2].[OrderID] AS [OrderID],
       [Extent2].[CustomerID] AS [CustomerID1],
       [Extent2].[EmployeeID] AS [EmployeeID],
       [Extent2].[OrderDate] AS [OrderDate],
       [Extent2].[RequiredDate] AS [RequiredDate],
       [Extent2].[ShippedDate] AS [ShippedDate],
       [Extent2].[ShipVia] AS [ShipVia],
       [Extent2].[Freight] AS [Freight],
       [Extent2].[ShipName] AS [ShipName],
       [Extent2].[ShipAddress] AS [ShipAddress],
       [Extent2].[ShipCity] AS [ShipCity],
       [Extent2].[ShipRegion] AS [ShipRegion],
       [Extent2].[ShipPostalCode] AS [ShipPostalCode],
       [Extent2].[ShipCountry] AS [ShipCountry],
      CASE WHEN ([Extent2].[OrderID] IS NULL) THEN CAST(NULL AS int) ELSE 1 END AS [C2]
      FROM  [dbo].[Customers] AS [Extent1]
      LEFT OUTER JOIN [dbo].[Orders] AS [Extent2] ON [Extent1].[CustomerID] = [Extent2].[CustomerID]
      WHERE N'UK' = [Extent1].[Country]
)  AS [Project1]
ORDER BY [Project1].[CustomerID] ASC, [Project1].[C2] ASC
```

При использовании отложенной загрузки, изначально будет выполните следующий запрос:

``` SQL
SELECT
[Extent1].[CustomerID] AS [CustomerID],
[Extent1].[CompanyName] AS [CompanyName],
[Extent1].[ContactName] AS [ContactName],
[Extent1].[ContactTitle] AS [ContactTitle],
[Extent1].[Address] AS [Address],
[Extent1].[City] AS [City],
[Extent1].[Region] AS [Region],
[Extent1].[PostalCode] AS [PostalCode],
[Extent1].[Country] AS [Country],
[Extent1].[Phone] AS [Phone],
[Extent1].[Fax] AS [Fax]
FROM [dbo].[Customers] AS [Extent1]
WHERE N'UK' = [Extent1].[Country]
```

И каждый раз при обращении к свойству навигации заказы клиента в хранилище выдается другой запрос следующим образом:

``` SQL
exec sp_executesql N'SELECT
[Extent1].[OrderID] AS [OrderID],
[Extent1].[CustomerID] AS [CustomerID],
[Extent1].[EmployeeID] AS [EmployeeID],
[Extent1].[OrderDate] AS [OrderDate],
[Extent1].[RequiredDate] AS [RequiredDate],
[Extent1].[ShippedDate] AS [ShippedDate],
[Extent1].[ShipVia] AS [ShipVia],
[Extent1].[Freight] AS [Freight],
[Extent1].[ShipName] AS [ShipName],
[Extent1].[ShipAddress] AS [ShipAddress],
[Extent1].[ShipCity] AS [ShipCity],
[Extent1].[ShipRegion] AS [ShipRegion],
[Extent1].[ShipPostalCode] AS [ShipPostalCode],
[Extent1].[ShipCountry] AS [ShipCountry]
FROM [dbo].[Orders] AS [Extent1]
WHERE [Extent1].[CustomerID] = @EntityKeyValue1',N'@EntityKeyValue1 nchar(5)',@EntityKeyValue1=N'AROUT'
```

Дополнительные сведения см. в разделе [загрузка связанных объектов](https://msdn.microsoft.com/library/bb896272.aspx).

#### <a name="821-lazy-loading-versus-eager-loading-cheat-sheet"></a>8.2.1 отложенную загрузку и упреждающая загрузка Памятка

Нет такого понятия, как универсальная выборе безотложную загрузку и отложенной загрузки. Сначала попытайтесь понять различия между обеими стратегиями, поэтому можно также обоснованное решение; Кроме того стоит, подходит ли ваш код в любой из следующих сценариев:

| Сценарий                                                                    | Наши предложения                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|:----------------------------------------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Требуется для доступа к многие свойства навигации из выбранных объектов? | **Не** -возможно, сделает оба варианта. Тем не менее если полезные данные, которые приносит запроса не является слишком большим, возможны выигрыш в производительности, используя Безотложную загрузку, так как он не требует сетевого обходов для материализации объектов. <br/> <br/> **Да** — Если вам требуется доступ к многие свойства навигации с сущностями, это делается, что с помощью нескольких включить операторы в запросе с безотлагательной загрузкой. Дополнительные сущности включаются, чем больше полезных данных, которые возвращает запрос. Когда вы включаете три или нескольких сущностей в запрос, подумайте о переходе в режим Lazy загрузки. |
| Знаете ли вы, точно какие данные потребуются во время выполнения?                   | **Не** -отложенная загрузка будет лучше для вас. В противном случае может появиться запрос данных, что вам не потребуется. <br/> <br/> **Да** - упреждающая загрузка, возможно, является лучшим решением; будет проще ускорения загрузки всей наборов. Если запрос требует выборки очень большой объем данных, и это становится слишком медленно, попробуйте вместо загрузки Lazy.                                                                                                                                                                                                                                                       |
| Ваш код выполняется далеко от базы данных? (задержка сети)  | **Не** — когда сетевая задержка не является проблемой, с помощью отложенная загрузка может упростить код. Помните, что топология приложения могут измениться, поэтому не принимают с учетом расположения базы данных как должное. <br/> <br/> **Да** — Если в сети только для проблем, можно решить, что лучше подходит для вашего сценария. Как правило, так как он требуется меньше циклов Безотложная загрузка будет лучше.                                                                                                                                                                                                      |


#### <a name="822-performance-concerns-with-multiple-includes"></a>8.2.2 включает в себя несколько, касающиеся производительности

Когда мы слышим вопросы производительности, включающие проблемы времени отклика сервера, источником проблемы является часто запросы с несколькими инструкциями Include. Во время, включая связанные сущности в запросе обладает широкими возможностями, важно понимать, что происходит на самом деле.

Занимает достаточно долго для запроса с несколькими инструкциями Include в его, чтобы перейти по нашей внутренней плана компилятора для создания команды хранилища. Большую часть этого времени расходуется оптимизации результирующий запрос. Команда созданного хранилища будет содержать Outer Join или Union для каждого Include, в зависимости от вашей сопоставления. Подобные запросы добавит больших графах подключенных из базы данных в одной полезной нагрузке, которая будет acerbate проблемы пропускной способности, особенно в том случае, если есть много избыточности в полезных данных (например, при использовании нескольких уровней Include для обхода ассоциации в направлении один ко многим).

Можно проверить для случаев, где запросы возвращается слишком большого объема полезных данных путем доступа к базовой TSQL для запроса с помощью ToTraceString, выполнив команду хранилища в SQL Server Management Studio, чтобы просмотреть размер полезных данных. В таких случаях вы можете повторить, чтобы уменьшить число операторов Include в запросе для только что перенесите нужные данные. Или можно разбить запрос на небольших последовательность вложенных запросов, например:

**До следующей запроса:**

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var customers = from c in context.Customers.Include(c => c.Orders)
                    where c.LastName.StartsWith(lastNameParameter)
                    select c;

    foreach (Customer customer in customers)
    {
        ...
    }
}
```

**После разбив его:**

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var orders = from o in context.Orders
                 where o.Customer.LastName.StartsWith(lastNameParameter)
                 select o;

    orders.Load();

    var customers = from c in context.Customers
                    where c.LastName.StartsWith(lastNameParameter)
                    select c;

    foreach (Customer customer in customers)
    {
        ...
    }
}
```

Это будет работать только в отслеживаемых запросах, как мы выполняем использование возможности контекст должен автоматически выполнить адресная привязка ассоциация и разрешение идентификаторов.

Как и в случае отложенной загрузки компромисс будут дополнительные запросы для меньшие порции данных. Проекции отдельные свойства также можно использовать явно установите только необходимые данные из каждой сущности, но не загружается сущностей в этом случае обновление не поддерживается.

#### <a name="823-workaround-to-get-lazy-loading-of-properties"></a>8.2.3 рекомендации для получения отложенная загрузка свойств

В настоящее время платформа Entity Framework не поддерживает отложенную загрузку скалярного или сложного свойства. Однако в случаях, где у вас есть таблицу, содержащую больших объектов, таких как большой двоичный объект, можно использовать разделение таблицы для разделения больших свойства в отдельную сущность. Например предположим, что имеется таблица продукции со столбцом photo varbinary. Если вам не нужно часто доступ к этому свойству в запросах, можно использовать для перевода в частях сущность, которая обычно необходимо разбиение таблиц. Сущность, представляющая фотография продукта будет загружаться только в тех случаях, когда она явно нужна.

Хороший ресурс, в котором показано, как включить разделение таблицы является Джил Финк «Таблица разделения в Entity Framework» в блоге: \<http://blogs.microsoft.co.il/blogs/gilf/archive/2009/10/13/table-splitting-in-entity-framework.aspx>.

## <a name="9-other-considerations"></a>9. другие вопросы

### <a name="91-server-garbage-collection"></a>9.1 сборка мусора сервера

Некоторые пользователи могут испытывать конфликта ресурсов, который ограничивает параллелизм, они ожидают, когда сборщик мусора не настроен должным образом. Каждый раз, когда EF используется в сценарии или в любом приложении, аналогичный системы на сервере, не забудьте включить сборка мусора сервера. Это делается с помощью простой параметр в файле конфигурации приложения:

``` xml
<?xmlversion="1.0" encoding="utf-8" ?>
<configuration>
        <runtime>
               <gcServer enabled="true" />
        </runtime>
</configuration>
```

Это следует уменьшить конфликты вашей потоков и повысить пропускную способность, до 30% в сценариях пропускная способность ЦП. В целом вы должны всегда тестировать поведение приложения с помощью классической сбора мусора (настроенный лучше для сценариев на стороне пользовательского интерфейса и клиента) а также сборка мусора сервера.

### <a name="92-autodetectchanges"></a>9.2 AutoDetectChanges

Как упоминалось ранее, Entity Framework может показывать проблем с производительностью, когда кэш объектов большим количеством сущностей. Некоторые операции, например добавления, удаления, поиска, запись и SaveChanges, активировать вызовы к DetectChanges, который может использовать большой объем ЦП, в зависимости от размера кэша объектов стал. Причиной этого является то, что кэш объектов и повторите диспетчер состояния объекта оставаться как синхронизированным, при каждой операции, выполняемые к контексту, таким образом, производимых данных гарантированно будет правильно под широкий набор сценариев.

Обычно рекомендуется оставить Entity Framework автоматическое обнаружение изменений для всего жизненного цикла приложения. Если вашего сценария отрицательно влияет высокой загрузки ЦП и профили указывают, что выяснилось, это вызов DetectChanges, рассмотрите возможность временного отключения AutoDetectChanges в важные части кода:

``` csharp
try
{
    context.Configuration.AutoDetectChangesEnabled = false;
    var product = context.Products.Find(productId);
    ...
}
finally
{
    context.Configuration.AutoDetectChangesEnabled = true;
}
```

Прежде чем отключать AutoDetectChanges, важно понимать, что это может привести к платформе Entity Framework теряет способность отслеживать определенные сведения об изменениях, которые выполняются в сущности. Если обрабатывается неправильно, это может привести к несогласованности данных на приложение. Дополнительные сведения об отключении AutoDetectChanges см. в статье \<http://blog.oneunicorn.com/2012/03/12/secrets-of-detectchanges-part-3-switching-off-automatic-detectchanges/>.

### <a name="93-context-per-request"></a>9.3 контекст каждого запроса

Контексты Entity Framework предназначены для использования в качестве небольшим временем существования экземпляров, чтобы обеспечить максимальную производительность работы. Контексты должны быть коротким и выполнявшей удаляются и таким образом были реализованы очень простая и reutilize метаданных, когда это возможно. В сценариях веб-важно иметь в виду и обладает контекстом дольше, чем длительность одного запроса. Аналогичным образом в сценариях веб-контекста следует удалить зависимости от понимания различные уровни кэширования в Entity Framework. Вообще говоря один следует избегать наличия экземпляр контекста на протяжении всего жизненного цикла приложения, а также контексты каждого потока и статические контекстов.

### <a name="94-database-null-semantics"></a>9.4 null-семантика базы данных

Entity Framework по умолчанию будет генерировать код SQL, который имеет C\# значение null, семантика сравнения. Рассмотрим следующий запрос:

``` csharp
            int? categoryId = 7;
            int? supplierId = 8;
            decimal? unitPrice = 0;
            short? unitsInStock = 100;
            short? unitsOnOrder = 20;
            short? reorderLevel = null;

            var q = from p incontext.Products
                    wherep.Category.CategoryName == "Beverages"
                          || (p.CategoryID == categoryId
                                || p.SupplierID == supplierId
                                || p.UnitPrice == unitPrice
                                || p.UnitsInStock == unitsInStock
                                || p.UnitsOnOrder == unitsOnOrder
                                || p.ReorderLevel == reorderLevel)
                    select p;

            var r = q.ToList();
```

В этом примере мы сравниваете ряд переменных, допускающие значение NULL по обнуляемые свойства сущности, такие как SupplierID и «цена». Созданный код SQL для этого запроса запросит в том случае, если значение параметра является таким же, как значение столбца, или если оба параметра, так и значения столбцов имеют значение null. Это будет скрыт способ сервера базы данных обрабатывает значения NULL и будет предоставлять согласованные C\# null взаимодействие через различные поставщики баз данных. С другой стороны, созданный код немного запутанным и не может выполнять when хорошо количество сравнений в where инструкции запроса увеличивается на большом числе.

Один из способов решения данной проблемы — с помощью семантику null базы данных. Обратите внимание, что это потенциально может работать по-разному для C\# null семантику, так как теперь Entity Framework будет генерировать более простой код SQL, который предоставляет способ СУБД обрабатывает значения null. Семантика null базы данных может быть активированные на контекста с помощью одной строки одной конфигурации для контекста конфигурации:

``` csharp
                context.Configuration.UseDatabaseNullSemantics = true;
```

Предприятиям среднего размера запросы не отобразит заметного производительность при использовании семантику null базы данных, но разница станут заметными на запросы с большим числом потенциальных сравнений со значением null.

В приведенном выше примере запроса разница в производительности был меньше, чем 2% microbenchmark, запущенных в управляемой среде.

### <a name="95-async"></a>9.5      Async

Поддержка Entity Framework 6 появились асинхронных операций, при выполнении в .NET 4.5 или более поздней версии. По большей части, приложений, имеющих операций ввода-ВЫВОДА, связанных с конфликтов будет будут наиболее выгодны с помощью асинхронного запроса и операции сохранения. Если приложение не страдал состязание ввода-ВЫВОДА, использование async в лучшем случае синхронного выполнения и возвращают результат, в то же количество времени в виде синхронного вызова или в худшем случае, просто отложить выполнение асинхронной задачи и добавьте дополнительный Тим e для выполнения вашего сценария.

Сведения о асинхронных задач программирования, которые помогут вам решить, если асинхронный улучшит производительность приложения посетите [http://msdn.microsoft.com/library/hh191443.aspx](https://msdn.microsoft.com/library/hh191443.aspx). Дополнительные сведения об использовании асинхронных операций в Entity Framework, см. в разделе [асинхронный запрос и сохранить](~/ef6/fundamentals/async.md
).

### <a name="96-ngen"></a>9.6 NGEN

Entity Framework 6 не поставляется в установке по умолчанию платформы .NET framework. Таким образом сборки .NET Framework сущности не являются NGEN будет по умолчанию, это означает, что весь код Entity Framework регулируется же затраты JIT'ing как любые другие сборки MSIL. Это может привести к снижению качества F5 во время разработки, а также холодного запуска приложения в рабочей среде. Чтобы снизить затраты на ЦП и памяти JIT'ing рекомендуется NGEN, Entity Framework образы соответствующим образом. Дополнительные сведения о том, как повысить производительность при запуске Entity Framework 6 с помощью NGEN см. в разделе [повышение производительности запуска с помощью NGen](~/ef6/fundamentals/performance/ngen.md).

### <a name="97-code-first-versus-edmx"></a>9.7 code First и EDMX

Entity Framework достигнуты проблему потери соответствия между объектно-ориентированного программирования и реляционных баз данных благодаря наличию хранимое в памяти представление концептуальной модели (объекты), схемы хранения (база данных) и сопоставление между два. Эти метаданные называется Entity Data Model – EDM для краткости. Из этой модели EDM Entity Framework являются производными представления для данных обмена данными объектов в памяти в базу данных и обратно.

При использовании Entity Framework с EDMX-файла, формально указывает концептуальной модели, схемы хранения и сопоставление, а затем стадию загрузки модели имеет только для проверки правильности модели EDM (например, убедитесь, что нет сопоставлений отсутствуют), затем Создание представлений, проверки представлений и иметь эти метаданные, готовой к использованию. Только может затем запрос можно выполнять, или сохранить новые данные в хранилище данных.

Подход Code First является, по существу, сложных генератор модели EDM. Имеет Entity Framework для создания EDM из предоставленного кода; Это достигается путем анализа классов, используемых в модели, применение соглашений и Настройка модели с помощью Fluent API. После построения модели EDM Entity Framework по сути работает так же образом, как он бы присутствовали в проект EDMX-файла. Таким образом при построении модели из Code First добавляет дополнительные осложнения, который преобразует в медленнее, время запуска для Entity Framework по сравнению с наличие EDMX. Стоимость зависит от размера и сложности модели, который строится.

Если вы решили использовать EDMX и Code First, важно знать, что гибкость, представленное в Code First увеличивается стоимость создания модели в первый раз. Если приложение может выдержать затраты на такую загрузку первого то обычно Code First будет предпочтительным способом для перехода.

## <a name="10-investigating-performance"></a>10 Исследование производительности

### <a name="101-using-the-visual-studio-profiler"></a>10.1 с помощью Visual Studio Profiler

Если возникают проблемы с производительностью с помощью Entity Framework, можно использовать профилировщик, аналогичный приведенному, встроенных в Visual Studio для см. в разделе, где приложение тратит свое время. Это средство, мы использовали для создания круговых диаграмм в записи блога «Обзор производительности платформы ADO.NET Entity Framework — часть 1» ( \<http://blogs.msdn.com/b/adonet/archive/2008/02/04/exploring-the-performance-of-the-ado-net-entity-framework-part-1.aspx>) , показывающие, где Entity Framework тратит свое время во время выполнения запросов "холодных" и "горячего" резервирования.

В записи блога «Профилирования Entity Framework с помощью Visual Studio Profiler 2010», написанной данных и моделирования группы консультирования клиентов представляет реальных пример того, как их использовать профилировщик для изучения проблемы производительности.  \<http://blogs.msdn.com/b/dmcat/archive/2010/04/30/profiling-entity-framework-using-the-visual-studio-2010-profiler.aspx>. Эта запись была написана для приложения windows. Если необходимо профилировать веб-приложение средства записи производительности Windows (WPR) и анализатор производительности Windows (WPA) может работать лучше, чем работе из Visual Studio. WPR и WPA являются частью Windows Performance Toolkit, который входит в состав комплекта средств для развертывания и оценки Windows ( [http://www.microsoft.com/download/details.aspx?id=39982](https://www.microsoft.com/download/details.aspx?id=39982)).

### <a name="102-applicationdatabase-profiling"></a>10.2 приложения или базы данных профилирования

Такие средства, как профилировщик, встроенных в Visual Studio сообщит о том, где приложение тратит время.  Другой тип профилировщик доступен, выполняет динамический анализ для запущенного приложения, в рабочей среде или подготовительной среде, в зависимости от потребностей и ищет общие проблемы и антишаблоны доступа к базе данных.

Два имеющихся на рынке профилировщика являются Entity Framework Profiler ( \<http://efprof.com>) и ORMProfiler ( \<http://ormprofiler.com>).

Если приложение является приложение MVC с использованием Code First, можно использовать в StackExchange MiniProfiler. Скотт Хансельман описывается этот инструмент в его блог по адресу: \<http://www.hanselman.com/blog/NuGetPackageOfTheWeek9ASPNETMiniProfilerFromStackExchangeRocksYourWorld.aspx>.

Дополнительные сведения о профилирование операций базы данных приложения, см. в статье журнала MSDN Magazine Джули Лерман под названием [профилирование операций с базой данных в Entity Framework](https://msdn.microsoft.com/magazine/gg490349.aspx).

### <a name="103-database-logger"></a>10.3 средство ведения журнала базы данных

Если вы используете Entity Framework 6 также рассмотреть возможность использования функции встроенного ведения журнала. Можно также указать свойства контекста базы данных для входа свои действия через простую конфигурацию одной строки:

``` csharp
    using (var context = newQueryComparison.DbC.NorthwindEntities())
    {
        context.Database.Log = Console.WriteLine;
        var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
        q.ToList();
    }
```

В этом примере активность базы данных будет записываться в консоль, но свойство журнала можно настроить для вызова любого действия&lt;строка&gt; делегировать.

Если вы хотите включить ведение журнала базы данных без повторной компиляции и вы используете Entity Framework 6.1 или более поздней версии, это можно сделать, добавив при этом перехватчик в файле web.config или app.config вашего приложения.

``` xml
  <interceptors>
    <interceptor type="System.Data.Entity.Infrastructure.Interception.DatabaseLogger, EntityFramework">
      <parameters>
        <parameter value="C:\Path\To\My\LogOutput.txt"/>
      </parameters>
    </interceptor>
  </interceptors>
```

Дополнительные сведения о том, как добавление ведения журнала без повторной компиляции перейдите в раздел \<http://blog.oneunicorn.com/2014/02/09/ef-6-1-turning-on-logging-without-recompiling/>.

## <a name="11-appendix"></a>Приложение 11

### <a name="111-a-test-environment"></a>11.1 A. тестовой среды

Эта среда использует настройки машины 2 с базой данных на отдельном компьютере из клиентского приложения. Машины находятся в одной стойке, поэтому задержки в сети является сравнительно мало, но более реалистичный чем среде одного компьютера.

#### <a name="1111-app-server"></a>11.1.1 сервер приложений

##### <a name="11111-software-environment"></a>11.1.1.1 программной среде

-   Программная среда Entity Framework 4
    -   Имя операционной системы: Windows Server 2008 R2 Enterprise с пакетом обновления 1.
    -   Visual Studio 2010 Ultimate.
    -   Visual Studio 2010 с пакетом обновления 1 (только для некоторых сравнения).
-   Программная среда Entity Framework 5 и 6
    -   Имя операционной системы: Windows 8,1 Enterprise
    -   Visual Studio 2013 — Ultimate.

##### <a name="11112-hardware-environment"></a>11.1.1.2 аппаратную среду

-   Двухъядерный процессор:     Intel(R) Xeon(R) CPU L5520 W3530 частотой 2,27 ГГц, 2261 Mhz8 ГГц, 4 ядер, 84 логических процессоров.
-   RamRAM 2412 ГБ.
-   136 ГБ SCSI250GB SATA 7200 об/мин 3 ГБИТ/с диска разделить на 4 разделов.

#### <a name="1112-db-server"></a>11.1.2 сервера базы данных

##### <a name="11121-software-environment"></a>11.1.2.1 программной среде

-   Имя операционной системы: Windows Server 2008 R28.1 Enterprise с пакетом обновления 1.
-   SQL Server 2008 R22012.

##### <a name="11122-hardware-environment"></a>11.1.2.2 аппаратную среду

-   Один процессор: Intel(R) Xeon(R) CPU L5520 частотой 2,27 ГГц, 2261 MhzES-1620 0 @ 3,60 ГГц, 4 ядер, 8 логических процессоров.
-   RamRAM 824 ГБ.
-   465 ГБ ATA500GB SATA 7200 об/мин 6 ГБИТ/с диска разделить на 4 разделов.

### <a name="112-b-query-performance-comparison-tests"></a>11.2 проверяет запрос б. Сравнение производительности

Модель Northwind был использован для выполнения этих тестов. Он был создан из базы данных с помощью конструктора Entity Framework. Затем следующий код был использован для сравнения производительности параметры выполнения запроса:

``` csharp
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Data.Entity.Infrastructure;
using System.Data.EntityClient;
using System.Data.Objects;
using System.Linq;

namespace QueryComparison
{
    public partial class NorthwindEntities : ObjectContext
    {
        private static readonly Func<NorthwindEntities, string, IQueryable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
            (NorthwindEntities context, string categoryName) =>
                context.Products.Where(p => p.Category.CategoryName == categoryName)
                );

        public IQueryable<Product> InvokeProductsForCategoryCQ(string categoryName)
        {
            return productsForCategoryCQ(this, categoryName);
        }
    }

    public class QueryTypePerfComparison
    {
        private static string entityConnectionStr = @"metadata=res://*/Northwind.csdl|res://*/Northwind.ssdl|res://*/Northwind.msl;provider=System.Data.SqlClient;provider connection string='data source=.;initial catalog=Northwind;integrated security=True;multipleactiveresultsets=True;App=EntityFramework'";

        public void LINQIncludingContextCreation()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {                 
                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void LINQNoTracking()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                context.Products.MergeOption = MergeOption.NoTracking;

                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void CompiledQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                var q = context.InvokeProductsForCategoryCQ("Beverages");
                q.ToList();
            }
        }

        public void ObjectQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                ObjectQuery<Product> products = context.Products.Where("it.Category.CategoryName = 'Beverages'");
                products.ToList();
            }
        }

        public void EntityCommand()
        {
            using (EntityConnection eConn = new EntityConnection(entityConnectionStr))
            {
                eConn.Open();
                EntityCommand cmd = eConn.CreateCommand();
                cmd.CommandText = "Select p From NorthwindEntities.Products As p Where p.Category.CategoryName = 'Beverages'";

                using (EntityDataReader reader = cmd.ExecuteReader(CommandBehavior.SequentialAccess))
                {
                    List<Product> productsList = new List<Product>();
                    while (reader.Read())
                    {
                        DbDataRecord record = (DbDataRecord)reader.GetValue(0);

                        // 'materialize' the product by accessing each field and value. Because we are materializing products, we won't have any nested data readers or records.
                        int fieldCount = record.FieldCount;

                        // Treat all products as Product, even if they are the subtype DiscontinuedProduct.
                        Product product = new Product();  

                        product.ProductID = record.GetInt32(0);
                        product.ProductName = record.GetString(1);
                        product.SupplierID = record.GetInt32(2);
                        product.CategoryID = record.GetInt32(3);
                        product.QuantityPerUnit = record.GetString(4);
                        product.UnitPrice = record.GetDecimal(5);
                        product.UnitsInStock = record.GetInt16(6);
                        product.UnitsOnOrder = record.GetInt16(7);
                        product.ReorderLevel = record.GetInt16(8);
                        product.Discontinued = record.GetBoolean(9);

                        productsList.Add(product);
                    }
                }
            }
        }

        public void ExecuteStoreQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                ObjectResult<Product> beverages = context.ExecuteStoreQuery<Product>(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void ExecuteStoreQueryDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var beverages = context.Database.SqlQuery\<QueryComparison.DbC.Product>(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void ExecuteStoreQueryDbSet()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var beverages = context.Products.SqlQuery(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void LINQIncludingContextCreationDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {                 
                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void LINQNoTrackingDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var q = context.Products.AsNoTracking().Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }
    }
}
```

### <a name="113-c-navision-model"></a>Модель Navision 11.3 C.

База данных Navision находится большой базы данных, используемый для демонстрации Microsoft Dynamics – NAV. Создаваемых концептуальных моделях содержит наборы сущностей 1005 и 4227 наборы ассоциаций. Модель, используемая в тесте «плоский» — не поддерживают наследование был добавлен к нему.

#### <a name="1131-queries-used-for-navision-tests"></a>11.3.1 запросы, используемые для тестов Navision

Список запросов, используемый с моделью Navision содержит 3 категорий запросов Entity SQL:

##### <a name="11311-lookup"></a>11.3.1.1 поиск

Простые поисковые запросы с нет агрегатов

-   Количество: 16232
-   Пример

``` xml
  <Query complexity="Lookup">
    <CommandText>Select value distinct top(4) e.Idle_Time From NavisionFKContext.Session as e</CommandText>
  </Query>
```

##### <a name="11312singleaggregating"></a>11.3.1.2 SingleAggregating

Обычный запрос бизнес-Аналитики с помощью нескольких статистических выражений, но не подытоги (одного запроса)

-   Количество: 2313
-   Пример

``` xml
  <Query complexity="SingleAggregating">
    <CommandText>NavisionFK.MDF_SessionLogin_Time_Max()</CommandText>
  </Query>
```

Где MDF\_SessionLogin\_время\_Max() определен в модели в виде:

``` xml
  <Function Name="MDF_SessionLogin_Time_Max" ReturnType="Collection(DateTime)">
    <DefiningExpression>SELECT VALUE Edm.Min(E.Login_Time) FROM NavisionFKContext.Session as E</DefiningExpression>
  </Function>
```

##### <a name="11313aggregatingsubtotals"></a>11.3.1.3 AggregatingSubtotals

Запрос бизнес-Аналитики с помощью агрегатов и промежуточные итоги (посредством объединения всех)

-   Количество: 178
-   Пример

``` xml
  <Query complexity="AggregatingSubtotals">
    <CommandText>
using NavisionFK;
function AmountConsumed(entities Collection([CRONUS_International_Ltd__Zone])) as
(
    Edm.Sum(select value N.Block_Movement FROM entities as E, E.CRONUS_International_Ltd__Bin as N)
)
function AmountConsumed(P1 Edm.Int32) as
(
    AmountConsumed(select value e from NavisionFKContext.CRONUS_International_Ltd__Zone as e where e.Zone_Ranking = P1)
)
----------------------------------------------------------------------------------------------------------------------
(
    select top(10) Zone_Ranking, Cross_Dock_Bin_Zone, AmountConsumed(GroupPartition(E))
    from NavisionFKContext.CRONUS_International_Ltd__Zone as E
    where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed
    group by E.Zone_Ranking, E.Cross_Dock_Bin_Zone
)
union all
(
    select top(10) Zone_Ranking, Cast(null as Edm.Byte) as P2, AmountConsumed(GroupPartition(E))
    from NavisionFKContext.CRONUS_International_Ltd__Zone as E
    where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed
    group by E.Zone_Ranking
)
union all
{
    Row(Cast(null as Edm.Int32) as P1, Cast(null as Edm.Byte) as P2, AmountConsumed(select value E
                                                                         from NavisionFKContext.CRONUS_International_Ltd__Zone as E
                                                                         where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed))
}</CommandText>
    <Parameters>
      <Parameter Name="MinAmountConsumed" DbType="Int32" Value="10000" />
    </Parameters>
  </Query>
```
