---
title: Связи, свойства навигации и внешние ключи - EF6
author: divega
ms.date: 10/23/2016
ms.assetid: 8a21ae73-6d9b-4b50-838a-ec1fddffcf37
ms.openlocfilehash: 8292ae7af8d760240715854611d92ab340bf1ca7
ms.sourcegitcommit: eb8359b7ab3b0a1a08522faf67b703a00ecdcefd
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/21/2019
ms.locfileid: "58319196"
---
# <a name="relationships-navigation-properties-and-foreign-keys"></a>Связи, свойства навигации и внешние ключи
Этот раздел содержит общие сведения о том, как платформа Entity Framework управляет связи между сущностями. Она также предоставляет некоторые рекомендации о том, как сопоставить и управлять связями.

## <a name="relationships-in-ef"></a>Связи в EF

В реляционных базах данных связи (также называемый связи) между таблицами определяются через внешние ключи. Внешний ключ (FK) — столбец или сочетание столбцов, который используется для принудительного связи между данными в двух таблицах. Обычно существует три типа связей: один к одному, один ко многим и многие ко многим. В отношении "один ко многим" внешний ключ определен в таблице много окончания отношения. Связь многие ко многим включает в себя определением третьей таблицы (другое название таблицу соединения или соединения), первичный ключ состоит из внешних ключей из обоих связанных таблиц. В взаимно-однозначной связи Кроме того, как внешний ключ действует первичный ключ и отсутствует отдельный столбец внешнего ключа, для любой из таблиц.

На следующем рисунке две таблицы, участвующие в связи один ко многим. **Курс** таблица является зависимой таблицы, так как она содержит **DepartmentID** столбец, который связывает его с **отдел** таблицы.

![Таблицы, подразделение и курс](~/ef6/media/database2.png)

В Entity Framework сущности могут быть связаны с другими сущностями через связь или связь. Каждое отношение содержит две конечные точки, описывающих тип сущности и кратность типа (один, ноль или один или множество) для двух сущностей в этой связи. Связи могут регулироваться ссылочное ограничение, описывающий, какие конечных элементов отношения относится к основной роли, а какой зависимой роли.

Свойства навигации предоставляют способ навигации по ассоциации между двумя типами сущностей. Каждый объект может обладать свойством навигации для каждого отношения, в котором участвует. Свойства навигации позволяют перейти связей и управление ими в обоих направлениях, возвращая объект ссылки (если атрибут кратности имеет один или ноль или один) или коллекции (Если кратность равна много). Также можно иметь односторонней навигации в этом случае только на одном из типов, участвует в связи, а не на оба определения свойства навигации.

Рекомендуется, чтобы включить свойства в модели, которые сопоставляются с внешними ключами в базе данных. Включение свойств внешних ключей позволяет создавать или изменять отношение, изменяя значение внешнего ключа для зависимого объекта. Сопоставление такого типа называется сопоставлением на основе внешнего ключа. С помощью внешних ключей еще более важно при работе с отсоединенных сущностей. Обратите внимание, что при работе с 1-к-1 или 1-0... 1 связи отсутствует отдельный столбец внешнего ключа, со свойством первичного ключа выступает в качестве внешнего ключа и всегда включается в модель.

Если внешние ключевые столбцы не включены в модель, данные сопоставления управляется как независимый объект. Отношения отслеживаются с помощью ссылки на объекты вместо свойств внешнего ключа. Этот тип связи называется *независимом сопоставлении*. Наиболее распространенный способ изменить *независимом сопоставлении* является изменение свойства навигации, которые создаются для каждой сущности, участвующей в ассоциации.

В модели можно использовать один или оба типа сопоставлений. Тем не менее если у вас есть чистые связь многие ко многим, связанной с таблице соединения, которая содержит только внешние ключи, EF будет использовать независимом сопоставлении для управления таких связей многие ко многим.   

Ниже показана концептуальная модель, созданную с помощью Entity Framework Designer. Модель содержит две сущности, участвующие в связи один ко многим. Обе эти сущности имеют свойства навигации. **Курс** depend сущность и имеет **DepartmentID** определено свойство внешнего ключа.

![Таблицы Department и курс со свойствами навигации](~/ef6/media/relationshipefdesigner.png)

В следующем фрагменте кода та же модель, созданную с помощью Code First.

``` csharp
public class Course
{
  public int CourseID { get; set; }
  public string Title { get; set; }
  public int Credits { get; set; }
  public int DepartmentID { get; set; }
  public virtual Department Department { get; set; }
}

public class Department
{
   public Department()
   {
     this.Courses = new HashSet<Course>();
   }  
   public int DepartmentID { get; set; }
   public string Name { get; set; }
   public decimal Budget { get; set; }
   public DateTime StartDate { get; set; }
   public int? Administrator {get ; set; }
   public virtual ICollection<Course> Courses { get; set; }
}
```

## <a name="configuring-or-mapping-relationships"></a>Настройка или сопоставление связей

Оставшуюся часть этой страницы описывается, как получить доступ и использовать данные с помощью связей. Сведения о настройке связи в модели см. следующие страницы.

-   Для настройки связей в Code First, см. в разделе [заметок к данным](~/ef6/modeling/code-first/data-annotations.md) и [Fluent API — связи](~/ef6/modeling/code-first/fluent/relationships.md).
-   Настройка связи с помощью Entity Framework Designer, см. в разделе [связи в конструкторе EF](~/ef6/modeling/designer/relationships.md).

## <a name="creating-and-modifying-relationships"></a>Создание и изменение отношений

В *ассоциации внешнего ключа*, при изменении отношения состояние зависимого объекта с `EntityState.Unchanged` состояние изменяется на `EntityState.Modified`. В отношении независимых изменение отношения не обновляет состояние зависимого объекта.

Следующие примеры демонстрируют использование свойств внешнего ключа и свойства навигации для сопоставления связанных объектов. С помощью ассоциации внешних ключей каждый из этих методов можно использовать для изменения, создания или изменения связей. Для независимых сопоставлений нельзя использовать свойство внешнего ключа.

- Присваивая новое значение свойству внешнего ключа, как показано в следующем примере.  
  ``` csharp
  course.DepartmentID = newCourse.DepartmentID;
  ```

- Следующий код удаляет связь, задавая внешний ключ **null**. Обратите внимание, что свойство внешнего ключа должен допускать значение NULL.  
  ``` csharp
  course.DepartmentID = null;
  ```

  >[!NOTE]
  > Если ссылка находится в добавленном состоянии (в этом примере объект курса), свойство навигации ссылки не будут синхронизированы с значениями ключа нового объекта, пока не вызове метода SaveChanges. Синхронизация не выполняется, поскольку контекст объекта не содержит постоянных ключей для добавленных объектов, пока они не будут сохранены. Если необходимо выполнить полную синхронизацию сразу же установите связь новых объектов, используйте один из следующих methods.*

- С помощью присваивания нового объекта свойству навигации. Следующий код создает связь между курс и `department`. Если объекты присоединены к контексту, `course` также добавляется `department.Courses` коллекции и соответствующим внешним ключевое свойство на `course` объекта присваивается значение ключевого свойства отдела.  
  ``` csharp
  course.Department = department;
  ```

- Чтобы удалить связь, присвойте свойству навигации `null`. Если вы работаете с платформой Entity Framework, который основан на .NET 4.0, связанный элемент должен быть загружен, прежде чем ему присвоено значение null. Пример:   
  ``` csharp
  context.Entry(course).Reference(c => c.Department).Load();
  course.Department = null;
  ```

  Начиная с Entity Framework 5.0, который основан на .NET 4.5, можно задать связь значение null без загрузки связанного окончания. Можно также задать текущее значение NULL, используя следующий метод.   
  ``` csharp
  context.Entry(course).Reference(c => c.Department).CurrentValue = null;
  ```

- Путем удаления или добавления объекта в коллекцию сущностей. Например, можно добавить объект типа `Course` для `department.Courses` коллекции. Эта операция создает отношение между конкретным **курс** и конкретным `department`. Если объекты присоединены к контекст, ссылку на подразделение и свойства внешнего ключа на **курс** будет установлен объект к соответствующему `department`.  
  ``` csharp
  department.Courses.Add(newCourse);
  ```

- С помощью `ChangeRelationshipState` метод, чтобы изменить состояние указанного отношения между двумя объектами сущностей. Этот метод наиболее часто используется при работе с N-уровневые приложения и *независимом сопоставлении* (он не может использоваться с сопоставлением на основе внешнего ключа). Кроме того, для использования этого метода необходимо удалить вниз до `ObjectContext`, как показано в следующем примере.  
В следующем примере устанавливается отношение "многие ко многим" между инструкторов и курсы. Вызов `ChangeRelationshipState` и передав `EntityState.Added` параметр, позволяет `SchoolContext` знать, что добавлен связь между двумя объектами:
  ``` csharp

  ((IObjectContextAdapter)context).ObjectContext.
    ObjectStateManager.
    ChangeRelationshipState(course, instructor, c => c.Instructor, EntityState.Added);
  ```

  Обратите внимание, что при обновлении (не просто прибавляет) связи, необходимо удалить старые связь после добавления новой:

  ``` csharp
  ((IObjectContextAdapter)context).ObjectContext.
    ObjectStateManager.
    ChangeRelationshipState(course, oldInstructor, c => c.Instructor, EntityState.Deleted);
  ```

## <a name="synchronizing-the-changes-between-the-foreign-keys-and-navigation-properties"></a>Синхронизация изменений между внешними ключами и свойств навигации

При изменении отношения объектов, присоединенных к контексту с помощью одного из описанных выше методов Entity Framework необходимо синхронизировать внешние ключи, ссылки и коллекции. Платформа Entity Framework автоматически управляет Эта синхронизация (также известный как связь исправление up) для сущностей POCO с прокси-серверами. Дополнительные сведения см. в разделе [работа с прокси](~/ef6/fundamentals/proxies.md).

При использовании сущностей POCO без прокси-объектов, необходимо убедиться в том, **DetectChanges** метод вызывается для синхронизации связанных объектов в контексте. Обратите, внимание, что следующие API автоматически активирует **DetectChanges** вызова.

-   `DbSet.Add`
-   `DbSet.AddRange`
-   `DbSet.Remove`
-   `DbSet.RemoveRange`
-   `DbSet.Find`
-   `DbSet.Local`
-   `DbContext.SaveChanges`
-   `DbSet.Attach`
-   `DbContext.GetValidationErrors`
-   `DbContext.Entry`
-   `DbChangeTracker.Entries`
-   Выполнение LINQ запросы к `DbSet`

## <a name="loading-related-objects"></a>Загрузка связанных объектов

В Entity Framework часто используются свойства навигации для загрузки сущностей, которые связаны с возвращенной сущностью посредством определенной ассоциации. Дополнительные сведения см. в разделе [загрузка связанных объектов](~/ef6/querying/related-data.md).

> [!NOTE]
> В сопоставлении на основе внешнего ключа при загрузке связанного конечного элемента зависимого объекта связанный объект загружается на основе значения внешнего ключа зависимого объекта, находящегося на момент загрузки в памяти:

``` csharp
    // Get the course where currently DepartmentID = 2.
    Course course2 = context.Courses.First(c=>c.DepartmentID == 2);

    // Use DepartmentID foreign key property
    // to change the association.
    course2.DepartmentID = 3;

    // Load the related Department where DepartmentID = 3
    context.Entry(course).Reference(c => c.Department).Load();
```

В независимом сопоставлении связанный конечный элемент зависимого объекта запрашивается на основе значения внешнего ключа зависимого объекта, находящегося на момент загрузки в базе данных. Тем не менее если отношение изменено и ссылочное свойство зависимого объекта указывает на разные основного объекта, который загружается в контексте объекта Entity Framework будет пытаться создать отношение, как он определен на клиенте.

## <a name="managing-concurrency"></a>Управление параллелизмом

Внешний ключ, и для независимых сопоставлений проверки параллелизма основаны на ключах сущностей и других свойствах сущностей, определенных в модели. При использовании EF конструктора для создания модели, задайте `ConcurrencyMode` атрибут **фиксированной** для указания, что свойство должно проверяться для параллелизма. При использовании Code First для определения модели используйте `ConcurrencyCheck` заметки на свойства, которые будут проверяться для параллелизма. При работе в режиме Code First можно также использовать `TimeStamp` заметки, чтобы указать, что свойство должно проверяться для параллелизма. В одном классе может иметь только одно свойство метки времени. Во-первых, это свойство карты кода к полю, не допускающие значения NULL в базе данных.

Мы рекомендуем всегда использовать ассоциации внешнего ключа при работе с сущностями, участвующие в проверке параллелизма и разрешения.

Дополнительные сведения см. в разделе [обработка конфликтов параллелизма](~/ef6/saving/concurrency.md).

## <a name="working-with-overlapping-keys"></a>Работа с перекрывающимися ключами

Перекрывающиеся ключи представляют собой составные ключи, некоторые из свойств в которых также являются частью другого ключа в сущности. Для независимых сопоставлений использовать перекрывающиеся ключи нельзя. Для изменения сопоставления на основе внешнего ключа, содержащей перекрывающиеся ключи, рекомендуется изменять значения внешнего ключа вместо использования ссылок на объекты.
