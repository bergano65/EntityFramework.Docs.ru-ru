---
title: Конструктор-хранимые процедуры CUD — EF6
author: divega
ms.date: 10/23/2016
ms.assetid: 1e773972-2da5-45e0-85a2-3cf3fbcfa5cf
ms.openlocfilehash: bdb0df969c33d5ad3f103bfa9af6002c9c2bb9b3
ms.sourcegitcommit: cc0ff36e46e9ed3527638f7208000e8521faef2e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78415145"
---
# <a name="designer-cud-stored-procedures"></a>Конструктор хранимых процедур CUD

В этом пошаговом руководстве показано, как сопоставлять операции создания\\вставки, обновления и удаления (CUD) типа сущности с хранимыми процедурами с помощью Entity Framework Designer (EF Designer).  По умолчанию Entity Framework автоматически создает инструкции SQL для операций CUD, но можно также сопоставлять хранимые процедуры с этими операциями.  

Обратите внимание, что Code First не поддерживает сопоставление с хранимыми процедурами или функциями. Однако можно вызывать хранимые процедуры или функции с помощью метода System. Data. Entity. DbSet. SqlQuery. Пример:

``` csharp
var query = context.Products.SqlQuery("EXECUTE [dbo].[GetAllProducts]");
```

## <a name="considerations-when-mapping-the-cud-operations-to-stored-procedures"></a>Рекомендации по сопоставлению операций CUD с хранимыми процедурами

При сопоставлении операций CUD с хранимыми процедурами применяются следующие соображения.

- При сопоставлении одной из операций CUD с хранимой процедурой сопоставьте все эти операции. Если не выполнить сопоставление всех трех, то несопоставленные операции завершатся неудачно, если будет вызвано  **упдатиксцептион** .
- Необходимо сопоставлять каждый параметр хранимой процедуры со свойствами сущности.
- Если сервер создает значение первичного ключа для вставленной строки, необходимо преобразовать это значение обратно в свойство ключа сущности. В следующем примере хранимая процедура **инсертперсон** Возвращает созданный первичный ключ как часть результирующего набора хранимой процедуры. Первичный ключ сопоставляется с ключом сущности (**PersonID**) с помощью **&lt;Добавление привязок результатов&gt;**  функции конструктора EF.
- Вызовы хранимых процедур сопоставляются с сущностями в концептуальной модели 1:1. Например, если в концептуальной модели реализуется иерархия наследования, а затем сопоставляются хранимые процедуры CUD **для родительских** (базовых) **и дочерних** (производных) сущностей, сохранение **дочерних** изменений приведет к вызову только хранимых процедур **дочернего**класса, а вызовы хранимых процедур **родительского**объекта не будут вызываться.

## <a name="prerequisites"></a>предварительные требования

Для выполнения данного пошагового руководства требуется:

- Последняя версия Visual Studio.
- [Образец базы данных School](~/ef6/resources/school-database.md).

## <a name="set-up-the-project"></a>Настройка проекта

- Откройте Visual Studio 2012.
- Выберите **файл —&gt; создать&gt; проект**
- В левой области щелкните **Visual C\#** , а затем выберите шаблон **консоли** .
- В качестве имени введите **кудспрокссампле** .
- Выберите **OK**.

## <a name="create-a-model"></a>Создание модели

- Щелкните правой кнопкой мыши имя проекта в обозреватель решений и выберите **Добавить-&gt; новый элемент**.
- Выберите **данные** в меню слева, а затем выберите **ADO.NET EDM** в области Шаблоны.
- Введите **кудспрокс. EDMX** в поле имя файла и нажмите кнопку **Добавить**.
- В диалоговом окне Выбор содержимого модели выберите пункт **создать из базы данных**, а затем нажмите кнопку **Далее**.
- Нажмите кнопку **создать соединение**. В диалоговом окне Свойства соединения введите имя сервера (например, **(LocalDB)\\mssqllocaldb**), выберите метод проверки подлинности, введите **School** в качестве имени базы данных и нажмите кнопку **ОК**.
    В диалоговом окне Выбор подключения к данным будет обновлен параметр подключения к базе данных.
- В диалоговом окне Выбор объектов базы данных в разделе **таблицы** узел выберите таблицу **Person** .
- Кроме того, выберите следующие хранимые процедуры в узле **хранимые процедуры и функции** : **делетеперсон**, **инсертперсон**и **упдатеперсон**.
- Начиная с Visual Studio 2012 конструктор EF поддерживает неполное импортирование хранимых процедур. По умолчанию флажок **Импорт выбранных хранимых процедур и функций в сущностную модель** установлен. Поскольку в этом примере у нас есть хранимые процедуры для вставки, обновления и удаления типов сущностей, мы не хотим импортировать их и снять этот флажок.

    ![Процедуры импорта S](~/ef6/media/importsprocs.jpg)

- Нажмите кнопку **Готово**.
    Отобразится конструктор EF, предоставляющий область конструктора для редактирования модели.

## <a name="map-the-person-entity-to-stored-procedures"></a>Сопоставьте сущность Person с хранимыми процедурами

- Щелкните правой кнопкой мыши объект **Person** тип сущности и выберите **сопоставление хранимых процедур**.
- Сопоставления хранимых процедур отображаются в окне **сведения о Сопоставлении** .
- Нажмите кнопку **&lt;выберите Вставить функцию&gt;** .
    Поле становится раскрывающимся списком хранимых процедур в модели хранения, которые могут быть сопоставлены с типами сущностей в концептуальной модели.
    Выберите **инсертперсон** из раскрывающегося списка.
- Появятся применяемые по умолчанию сопоставления параметров хранимой процедуры со свойствами сущности. Обратите внимание, что стрелки указывают направление сопоставления: «Значения свойств передаются параметрам хранимой процедуры».
- Щелкните **&lt;добавить привязку результата&gt;** .
- Введите **невперсонид**, имя параметра, возвращаемое хранимой процедурой **инсертперсон** . Убедитесь, что не вводите начальные или конечные пробелы.
- Нажмите клавишу **Ввод**.
- По умолчанию **невперсонид** сопоставляется с ключом сущности **PersonID**. Обратите внимание, что стрелка указывает направление сопоставления — значение столбца результата передается свойству.

    ![Сведения о сопоставлении](~/ef6/media/mappingdetails.png)

- Щелкните **&lt;выберите обновить функцию&gt;**  а затем выберите **упдатеперсон** в открывшемся раскрывающемся списке.
- Появятся применяемые по умолчанию сопоставления параметров хранимой процедуры со свойствами сущности.
- Щелкните **&lt;выберите Удалить функцию&gt;**  а затем выберите **делетеперсон** в открывшемся раскрывающемся списке.
- Появятся применяемые по умолчанию сопоставления параметров хранимой процедуры со свойствами сущности.

Операции вставки, обновления и удаления типа сущности **Person** теперь сопоставлены с хранимыми процедурами.

Если необходимо включить проверку параллелизма при обновлении или удалении сущности с хранимыми процедурами, используйте один из следующих вариантов.

- Используйте **выходной** параметр, чтобы получить количество затронутых строк из хранимой процедуры и установить флажок **затронутые строки** флажок рядом с именем параметра. Если возвращаемое значение равно нулю при вызове операции, будет выдано исключение  [**оптимистикконкурренциексцептион**](https://msdn.microsoft.com/library/system.data.optimisticconcurrencyexception.aspx) .
- Установите флажок **использовать исходное значение** рядом со свойством, которое необходимо использовать для проверки параллелизма. При попытке обновления значение свойства, которое было первоначально считано из базы данных, будет использоваться при записи данных обратно в базу данных. Если значение не совпадает со значением в базе данных, будет выдано **оптимистикконкурренциексцептион** .

## <a name="use-the-model"></a>Использование модели

Откройте файл **Program.CS** , в котором определен метод **Main** . Добавьте следующий код в функцию main.

Код создает новый объект **Person** , затем обновляет объект и, наконец, удаляет объект.

``` csharp
    using (var context = new SchoolEntities())
    {
        var newInstructor = new Person
        {
            FirstName = "Robyn",
            LastName = "Martin",
            HireDate = DateTime.Now,
            Discriminator = "Instructor"
        }

        // Add the new object to the context.
        context.People.Add(newInstructor);

        Console.WriteLine("Added {0} {1} to the context.",
            newInstructor.FirstName, newInstructor.LastName);

        Console.WriteLine("Before SaveChanges, the PersonID is: {0}",
            newInstructor.PersonID);

        // SaveChanges will call the InsertPerson sproc.  
        // The PersonID property will be assigned the value
        // returned by the sproc.
        context.SaveChanges();

        Console.WriteLine("After SaveChanges, the PersonID is: {0}",
            newInstructor.PersonID);

        // Modify the object and call SaveChanges.
        // This time, the UpdatePerson will be called.
        newInstructor.FirstName = "Rachel";
        context.SaveChanges();

        // Remove the object from the context and call SaveChanges.
        // The DeletePerson sproc will be called.
        context.People.Remove(newInstructor);
        context.SaveChanges();

        Person deletedInstructor = context.People.
            Where(p => p.PersonID == newInstructor.PersonID).
            FirstOrDefault();

        if (deletedInstructor == null)
            Console.WriteLine("A person with PersonID {0} was deleted.",
                newInstructor.PersonID);
    }
```

- Скомпилируйте и запустите приложение. Программа выдает следующие выходные данные *

> [!NOTE]
> PersonID автоматически создается сервером, поэтому, скорее всего, будет отображаться другое число *

``` Output
Added Robyn Martin to the context.
Before SaveChanges, the PersonID is: 0
After SaveChanges, the PersonID is: 51
A person with PersonID 51 was deleted.
```

При работе с конечной версией Visual Studio можно использовать IntelliTrace с отладчиком для просмотра инструкций SQL, которые будут выполнены.

![IntelliTrace](~/ef6/media/intellitrace.png)
