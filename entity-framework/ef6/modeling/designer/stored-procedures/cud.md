---
title: Конструктор-хранимые процедуры CUD — EF6
author: divega
ms.date: 10/23/2016
ms.assetid: 1e773972-2da5-45e0-85a2-3cf3fbcfa5cf
ms.openlocfilehash: bdb0df969c33d5ad3f103bfa9af6002c9c2bb9b3
ms.sourcegitcommit: 6c28926a1e35e392b198a8729fc13c1c1968a27b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/02/2019
ms.locfileid: "71813559"
---
# <a name="designer-cud-stored-procedures"></a>Конструктор хранимых процедур CUD

В этом пошаговом руководстве показано, как сопоставлять операции Create @ no__t-0insert, Update и Delete (CUD) типа сущности с хранимыми процедурами с помощью Entity Framework Designer (EF Designer).  По умолчанию Entity Framework автоматически создает инструкции SQL для операций CUD, но можно также сопоставлять хранимые процедуры с этими операциями.  

Обратите внимание, что Code First не поддерживает сопоставление с хранимыми процедурами или функциями. Однако можно вызывать хранимые процедуры или функции с помощью метода System. Data. Entity. DbSet. SqlQuery. Пример:

``` csharp
var query = context.Products.SqlQuery("EXECUTE [dbo].[GetAllProducts]");
```

## <a name="considerations-when-mapping-the-cud-operations-to-stored-procedures"></a>Рекомендации по сопоставлению операций CUD с хранимыми процедурами

При сопоставлении операций CUD с хранимыми процедурами применяются следующие соображения.

- При сопоставлении одной из операций CUD с хранимой процедурой сопоставьте все эти операции. Если не выполнить сопоставление всех трех, несопоставленные операции завершатся неудачей, если они будут выполнены, и будет выдано исключение **упдатиксцептион** will.
- Необходимо сопоставлять каждый параметр хранимой процедуры со свойствами сущности.
- Если сервер создает значение первичного ключа для вставленной строки, необходимо преобразовать это значение обратно в свойство ключа сущности. В следующем примере процедура **инсертперсон** stored Возвращает созданный первичный ключ как часть результирующего набора хранимой процедуры. Первичный ключ сопоставляется с ключом сущности (**PersonID**) с помощью **привязок результатов &lt;Add @ no__t-3** feature конструктора EF.
- Вызовы хранимых процедур сопоставляются с сущностями в концептуальной модели 1:1. Например, если в концептуальной модели реализуется иерархия наследования, а затем сопоставляются хранимые процедуры CUD для **родительских** (базовых) и **дочерних** (производных) сущностей, сохранение **дочерних** изменений будет вызывать только **дочерний**элемент хранимых процедур, они не активируют вызовы хранимых процедур **родительского**объекта.

## <a name="prerequisites"></a>Предварительные требования

Для выполнения данного пошагового руководства требуется:

- Последняя версия Visual Studio.
- [Образец базы данных School](~/ef6/resources/school-database.md).

## <a name="set-up-the-project"></a>Настройка проекта

- Откройте Visual Studio 2012.
- Выберите **файл-&gt; новый проект-&gt;** .
- В левой области щелкните **Visual C @ no__t-1**, а затем выберите шаблон **консоли** .
- Введите **кудспрокссампле**@no__t — 1As имя.
- Нажмите кнопку **ОК**.

## <a name="create-a-model"></a>Создание модели

- Щелкните правой кнопкой мыши имя проекта в обозреватель решений и выберите **Добавить-&gt; новый элемент**.
- Выберите **данные** в меню слева, а затем выберите **ADO.NET EDM** в области Шаблоны.
- Введите **кудспрокс. EDMX** в поле имя файла и нажмите кнопку **Добавить**.
- В диалоговом окне Выбор содержимого модели выберите пункт **создать из базы данных**, а затем нажмите кнопку **Далее**.
- Нажмите кнопку **создать соединение**. В диалоговом окне Свойства соединения введите имя сервера (например, **(LocalDB)\\mssqllocaldb**), выберите метод проверки подлинности, введите **School** в качестве имени базы данных и нажмите кнопку **ОК**.
    В диалоговом окне Выбор подключения к данным будет обновлен параметр подключения к базе данных.
- В диалоговом окне Выбор объектов базы данных в разделе **таблицы** node выберите таблицу **Person** .
- Кроме того, выберите следующие хранимые процедуры в узле **хранимые процедуры и функции** : **Делетеперсон**, **инсертперсон**и **упдатеперсон**.
- Начиная с Visual Studio 2012 конструктор EF поддерживает неполное импортирование хранимых процедур. По умолчанию флажок **Импорт выбранных хранимых процедур и функций в сущностную модель** установлен. Поскольку в этом примере у нас есть хранимые процедуры для вставки, обновления и удаления типов сущностей, мы не хотим импортировать их и снять этот флажок.

    ![Процедуры импорта S](~/ef6/media/importsprocs.jpg)

- Нажмите кнопку **Готово**.
    Отобразится конструктор EF, предоставляющий область конструктора для редактирования модели.

## <a name="map-the-person-entity-to-stored-procedures"></a>Сопоставьте сущность Person с хранимыми процедурами

- Щелкните правой кнопкой мыши тип **Person** entity и выберите **сопоставление хранимых процедур**.
- Сопоставления хранимых процедур отображаются в **сведениях о Сопоставлении** window.
- Щелкните **&lt;Select вставить функцию @ no__t-2**.
    Поле становится раскрывающимся списком хранимых процедур в модели хранения, которые могут быть сопоставлены с типами сущностей в концептуальной модели.
    Выберите **инсертперсон** from раскрывающегося списка.
- Появятся применяемые по умолчанию сопоставления параметров хранимой процедуры со свойствами сущности. Обратите внимание на то, что направление сопоставления указывают стрелки: значения свойств передаются параметрам хранимой процедуры.
- Щелкните **&lt;Add результат привязка @ no__t-2**.
- Введите **невперсонид**, имя параметра, возвращаемое процедурой **инсертперсон** stored. Убедитесь, что не вводите начальные или конечные пробелы.
- Нажмите клавишу **Ввод**.
- По умолчанию **невперсонид** is, сопоставленный с ключом сущности **PersonID**. Обратите внимание на то, что стрелка указывает направление сопоставления: значение столбца результата передается свойству.

    ![Сведения о сопоставлении](~/ef6/media/mappingdetails.png)

- Щелкните **&lt;Select обновить функцию @ no__t-2** And выберите **упдатеперсон** from в итоговом раскрывающемся списке.
- Появятся применяемые по умолчанию сопоставления параметров хранимой процедуры со свойствами сущности.
- Щелкните **&lt;Select удалить функцию @ no__t-2** And select **делетеперсон** from в итоговом раскрывающемся списке.
- Появятся применяемые по умолчанию сопоставления параметров хранимой процедуры со свойствами сущности.

Операции вставки, обновления и удаления типа **Person** entity теперь сопоставлены с хранимыми процедурами.

Если необходимо включить проверку параллелизма при обновлении или удалении сущности с хранимыми процедурами, используйте один из следующих вариантов.

- Используйте **выходной** параметр, чтобы получить количество затронутых строк из хранимой процедуры и проверить **затронутый параметр Rows** checkbox рядом с именем параметра. Если возвращаемое значение равно нулю при вызове операции, выдается исключение  [**оптимистикконкурренциексцептион**](https://msdn.microsoft.com/library/system.data.optimisticconcurrencyexception.aspx) will.
- Установите флажок **использовать исходное значение** рядом со свойством, которое необходимо использовать для проверки параллелизма. При попытке обновления значение свойства, которое было первоначально считано из базы данных, будет использоваться при записи данных обратно в базу данных. Если значение не соответствует значению в базе данных, выдается исключение **оптимистикконкурренциексцептион** will.

## <a name="use-the-model"></a>Использование модели

Откройте файл **Program.CS** , в котором определен метод **Main** . Добавьте следующий код в функцию main.

Код создает новый объект **Person** , затем обновляет объект и, наконец, удаляет объект.

``` csharp
    using (var context = new SchoolEntities())
    {
        var newInstructor = new Person
        {
            FirstName = "Robyn",
            LastName = "Martin",
            HireDate = DateTime.Now,
            Discriminator = "Instructor"
        }

        // Add the new object to the context.
        context.People.Add(newInstructor);

        Console.WriteLine("Added {0} {1} to the context.",
            newInstructor.FirstName, newInstructor.LastName);

        Console.WriteLine("Before SaveChanges, the PersonID is: {0}",
            newInstructor.PersonID);

        // SaveChanges will call the InsertPerson sproc.  
        // The PersonID property will be assigned the value
        // returned by the sproc.
        context.SaveChanges();

        Console.WriteLine("After SaveChanges, the PersonID is: {0}",
            newInstructor.PersonID);

        // Modify the object and call SaveChanges.
        // This time, the UpdatePerson will be called.
        newInstructor.FirstName = "Rachel";
        context.SaveChanges();

        // Remove the object from the context and call SaveChanges.
        // The DeletePerson sproc will be called.
        context.People.Remove(newInstructor);
        context.SaveChanges();

        Person deletedInstructor = context.People.
            Where(p => p.PersonID == newInstructor.PersonID).
            FirstOrDefault();

        if (deletedInstructor == null)
            Console.WriteLine("A person with PersonID {0} was deleted.",
                newInstructor.PersonID);
    }
```

- Скомпилируйте и запустите приложение. Программа выдает следующие выходные данные *

> [!NOTE]
> PersonID автоматически создается сервером, поэтому, скорее всего, будет отображаться другое число *

``` Output
Added Robyn Martin to the context.
Before SaveChanges, the PersonID is: 0
After SaveChanges, the PersonID is: 51
A person with PersonID 51 was deleted.
```

При работе с конечной версией Visual Studio можно использовать IntelliTrace с отладчиком для просмотра инструкций SQL, которые будут выполнены.

![IntelliTrace](~/ef6/media/intellitrace.png)
